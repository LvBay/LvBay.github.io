<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="See you again">
<meta property="og:type" content="website">
<meta property="og:title" content="Z">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Z">
<meta property="og:description" content="See you again">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Z">
<meta name="twitter:description" content="See you again">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Z</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Z</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/设计模式/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T22:54:42+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HeadFirst设计模式"><a href="#HeadFirst设计模式" class="headerlink" title="HeadFirst设计模式"></a>HeadFirst设计模式</h1><p>花了一周时间把这本书读完了，感觉受益良多。其中有几个模式让我感觉相见恨晚，之前有几个项目场景如果能结合设计模式来实现，应该能节省很多维护的工作。还有其他几种设计模式，并没有感觉到它们的威力。另外，各个设计模式之间的差异也让我有点绕不出来，这个只能靠以后慢慢理清了。</p>
<h1 id="模式是什么？"><a href="#模式是什么？" class="headerlink" title="模式是什么？"></a>模式是什么？</h1><p>书中提到: 模式是在某情景下，针对某问题的某种解决方案。</p>
<ul>
<li>情景（情景）</li>
<li>问题（需求）</li>
<li>解决方案（模式）</li>
</ul>
<p>举个例子：</p>
<p>情景-我要准时上班<br>问题-我将钥匙锁在车里了<br>解决方案1-打破窗户，进入车内，启动引擎，然后开车上班</p>
<h1 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h1><p>设计模式在模式的基础上，还包括了适用性，即最佳实践。</p>
<p>上述的例子，打破窗户虽然是一种解决方案，但是没有解决成本约束，可能不是一个很好的解决方案。</p>
<h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>设计模式虽然不是原则，更不是法律，但是它提供了一种指导方针。</p>
<p>我最近几个月一直在纠结一个问题，如何才能写出优秀甚至完美的代码？之前的很多项目代码，我觉得用另外一种结构也可以实现，但是我不知道哪种选择才是最正确的，甚至我一度认为之前的代码都是垃圾代码。</p>
<p>了解了设计模式之后，我找到了一些答案。目前我现在认为在当前情境下，满足以下三个条件，就是优秀的代码</p>
<ul>
<li>条理清晰</li>
<li>易于维护</li>
<li>方便扩展</li>
</ul>
<p>至于完美的代码，当然存在，但是只有极少情况下才会出现：需求不会再更改了。</p>
<p>从这个角度上来说，<code>fmt.Pritln(&quot;Hello World&quot;)&quot;</code>也算是一句”完美”代码了 -_-</p>
<h1 id="如何学习设计模式？"><a href="#如何学习设计模式？" class="headerlink" title="如何学习设计模式？"></a>如何学习设计模式？</h1><h2 id="“反设计模式”-vs-设计模式"><a href="#“反设计模式”-vs-设计模式" class="headerlink" title="“反设计模式” vs 设计模式"></a>“反设计模式” vs 设计模式</h2><p>没有对比就没有伤害，针对遇到的问题，思考一些”反设计模式”,然后与设计模式做对比</p>
<h2 id="设计模式-vs-设计模式"><a href="#设计模式-vs-设计模式" class="headerlink" title="设计模式 vs 设计模式"></a>设计模式 vs 设计模式</h2><p>同一个问题，既能抽象工厂模式能解决，也能使用模版方法解决。横向对比设计模式之间的差异</p>
<h2 id="发掘开源项目中的设计模式"><a href="#发掘开源项目中的设计模式" class="headerlink" title="发掘开源项目中的设计模式"></a>发掘开源项目中的设计模式</h2><p>我在读这本书的时候，读到观察者模式会想到nsq，读到模版方法会想到beego controller的设计，读到工厂方法会想到jaeger中初始化存储组件的代码，读到go-redis客户端代码会想到命令模式。</p>
<p>优秀的开源项目肯定包含了大量的设计模式，以后阅读的时候可以好好品味。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>毕业两年半，来到新公司已经半年了，博客也停更半年了。接下来的2018希望能更认真的对待博客～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/12/golang的OpenTracing和jeager使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/golang的OpenTracing和jeager使用/" itemprop="url">golang的OpenTracing和jaeger使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T16:23:13+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="OpenTracing是什么？"><a href="#OpenTracing是什么？" class="headerlink" title="OpenTracing是什么？"></a>OpenTracing是什么？</h2><p>当代分布式跟踪系统（例如，Zipkin, Dapper, HTrace, X-Trace等）旨在解决这些问题，但是他们使用不兼容的API来实现各自的应用需求。尽管这些分布式追踪系统有着相似的API语法，但各种语言的开发人员依然很难将他们各自的系统（使用不同的语言和技术）和特定的分布式追踪系统进行整合.</p>
<p>OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 OpenTracing提供了用于运营支撑系统的和针对特定平台的辅助程序库。</p>
<p>已经实现OpenTracing协议的项目有：</p>
<ul>
<li>Zipkin</li>
<li>Jaeger</li>
<li>Appdash</li>
</ul>
<h2 id="jaeger和OpenTracing"><a href="#jaeger和OpenTracing" class="headerlink" title="jaeger和OpenTracing"></a>jaeger和OpenTracing</h2><p>jaeger实现了OpenTracing，而且后端存储支持memry(默认)，elasticsearch,cassandra</p>
<h2 id="jaeger使用"><a href="#jaeger使用" class="headerlink" title="jaeger使用"></a>jaeger使用</h2><p>创建一个支持serve模式和client模式的web服务</p>
<pre><code>// main.go
package main
import (
    &quot;flag&quot;
    &quot;log&quot;

    jaegerClientConfig &quot;github.com/uber/jaeger-client-go/config&quot;
)

var (
    serverPort = flag.String(&quot;port&quot;, &quot;8000&quot;, &quot;server port&quot;)
    // 默认为服务模式
    actorKind  = flag.String(&quot;actor&quot;, &quot;server&quot;, &quot;server or client&quot;)
)

const (
    server = &quot;server&quot;
    client = &quot;client&quot;
)

func main() {
    flag.Parse()

    if *actorKind != server &amp;&amp; *actorKind != client {
        log.Fatal(&quot;Please specify &apos;-actor server&apos; or &apos;-actor client&apos;&quot;)
    }

    cfg := jaegerClientConfig.Configuration{
        Sampler: &amp;jaegerClientConfig.SamplerConfig{
            Type:  &quot;const&quot;,
            Param: 1.0, // sample all traces
        },
    }
    // jaeger.NewRemoteReporter(transport)
    tracer, closer, _ := cfg.New(*actorKind)
    defer closer.Close()

    if *actorKind == server {
        runServer(tracer)
        return
    }

    runClient(tracer)

    // Close the tracer to guarantee that all spans that could
    // be still buffered in memory are sent to the tracing backend
    closer.Close()
}
</code></pre><p>服务器模式</p>
<pre><code>// server.go
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;

    &quot;github.com/opentracing-contrib/go-stdlib/nethttp&quot;
    &quot;github.com/opentracing/opentracing-go&quot;
)

func getTime(w http.ResponseWriter, r *http.Request) {
    log.Print(&quot;Received getTime request&quot;)
    t := time.Now()
    ts := t.Format(&quot;Mon Jan _2 15:04:05 2006&quot;)
    io.WriteString(w, fmt.Sprintf(&quot;The time is %s&quot;, ts))
}

func redirect(w http.ResponseWriter, r *http.Request) {
    http.Redirect(w, r,
        fmt.Sprintf(&quot;http://localhost:%s/gettime&quot;, *serverPort), 301)
}

func runServer(tracer opentracing.Tracer) {
    http.HandleFunc(&quot;/gettime&quot;, getTime)
    http.HandleFunc(&quot;/&quot;, redirect)
    log.Printf(&quot;Starting server on port %s&quot;, *serverPort)
    err := http.ListenAndServe(
        fmt.Sprintf(&quot;:%s&quot;, *serverPort),
        // use nethttp.Middleware to enable OpenTracing for server
        nethttp.Middleware(tracer, http.DefaultServeMux))
    if err != nil {
        log.Fatalf(&quot;Cannot start server: %s&quot;, err)
    }
}
</code></pre><p>客户端模式</p>
<pre><code>// client.go
package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/opentracing-contrib/go-stdlib/nethttp&quot;
    &quot;github.com/opentracing/opentracing-go&quot;
    &quot;github.com/opentracing/opentracing-go/ext&quot;
    otlog &quot;github.com/opentracing/opentracing-go/log&quot;
    &quot;golang.org/x/net/context&quot;
)

func runClient(tracer opentracing.Tracer) {
    // nethttp.Transport from go-stdlib will do the tracing
    c := &amp;http.Client{Transport: &amp;nethttp.Transport{}}

    // create a top-level span to represent full work of the client
    span := tracer.StartSpan(client)
    span.SetTag(string(ext.Component), client)
    defer span.Finish()
    ctx := opentracing.ContextWithSpan(context.Background(), span)

    req, err := http.NewRequest(
        &quot;GET&quot;,
        fmt.Sprintf(&quot;http://localhost:%s/&quot;, *serverPort),
        nil,
    )
    if err != nil {
        onError(span, err)
        return
    }

    req = req.WithContext(ctx)
    // wrap the request in nethttp.TraceRequest
    req, ht := nethttp.TraceRequest(tracer, req)
    defer ht.Finish()

    res, err := c.Do(req)
    if err != nil {
        onError(span, err)
        return
    }
    defer res.Body.Close()
    body, err := ioutil.ReadAll(res.Body)
    if err != nil {
        onError(span, err)
        return
    }
    fmt.Printf(&quot;Received result: %s\n&quot;, string(body))
}

func onError(span opentracing.Span, err error) {
    // handle errors by recording them in the span
    span.SetTag(string(ext.Error), true)
    span.LogKV(otlog.Error(err))
    log.Print(err)
}
</code></pre><p>编译<br>go build</p>
<p>执行客户端请求代码<br>    ./opentracing-go-nethttp-demo</p>
<p>运行jaeger的docker镜像<br>    docker run -d -p5775:5775/udp -p16686:16686 jaegertracing/all-in-one:latest</p>
<p>执行客户端代码<br>    ./opentracing-go-nethttp-demo -actor client</p>
<p>此时访问 <a href="http://localhost:16686就可以看到jaeger上的记录了。" target="_blank" rel="noopener">http://localhost:16686就可以看到jaeger上的记录了。</a></p>
<img src="/2018/06/12/golang的OpenTracing和jeager使用/jaeger1.png">
<p>但是记录好像少了点，只有jaeger-query的，client和server的信息都没记录，查了下资料发现是因为启动jaeger的时候有些端口没开放。</p>
<pre><code>docker run \
-p 5775:5775/udp \
-p 16686:16686 \
-p 6831:6831/udp \
-p 6832:6832/udp \
-p 5778:5778 \
-p 14268:14268 \
jaegertracing/all-in-one:latest
</code></pre><h2 id="封装http请求"><a href="#封装http请求" class="headerlink" title="封装http请求"></a>封装http请求</h2><p>上面的例子就是对http请求的trace</p>
<h2 id="将数据存储在es中"><a href="#将数据存储在es中" class="headerlink" title="将数据存储在es中"></a>将数据存储在es中</h2><p>暂时还没成功，后面会更新。这里先把目前的操作记录下来。</p>
<p>在本地用docker启动了elasticsearch</p>
<pre><code>docker run -d -p 9200:9200 -e &quot;http.host=0.0.0.0&quot; -e &quot;transport.host=127.0.0.1&quot; docker.elastic.co/elasticsearch/elasticsearch:5.4.0
</code></pre><p>在本地用docker-compose启动jaeger</p>
<p>doker-compose.yaml:</p>
<pre><code>jaegertracing:
image: jaegertracing/all-in-one:latest
ports:
    - &quot;5775:5775/udp&quot;
    - &quot;6831:6831/udp&quot;
    - &quot;6832:6832/udp&quot;
    - &quot;5778:5778&quot;
    - &quot;16686:16686&quot;
    - &quot;14268:14268&quot;
command:
    - &quot;/go/bin/standalone-linux&quot;
    - &quot;--span-storage.type=elasticsearch&quot;
    - &quot;--query.static-files=/go/src/jaeger-ui-build/build/&quot;
environment:
  - SPAN_STORAGE_TYPE=elasticsearch
</code></pre><p>报错：<br>    {“level”:”fatal”,”ts”:1528814826.4817529,”caller”:”standalone/main.go:106”,”msg”:”Failed to init storage factory”,”error”:”health check timeout: no Elasticsearch node available”,”errorVerbose”:”no Elasticsearch node available…</p>
<p>解决：</p>
<h3 id="启动es的方式改为："><a href="#启动es的方式改为：" class="headerlink" title="启动es的方式改为："></a>启动es的方式改为：</h3><pre><code>docker run -it --rm -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;xpack.security.enabled=false&quot; docker.elastic.co/elasticsearch/elasticsearch:5.4.0
</code></pre><h3 id="启动jaeger前将宿主主机ip写入到环境变量："><a href="#启动jaeger前将宿主主机ip写入到环境变量：" class="headerlink" title="启动jaeger前将宿主主机ip写入到环境变量："></a>启动jaeger前将宿主主机ip写入到环境变量：</h3><pre><code>export DOCKERHOST=$(ifconfig | grep -E &quot;([0-9]{1,3}\.){3}[0-9]{1,3}&quot; | grep -v 127.0.0.1 | awk &apos;{ print $2 }&apos; | cut -f2 -d: | head -n1)
</code></pre><h3 id="修改docker-compose文件"><a href="#修改docker-compose文件" class="headerlink" title="修改docker-compose文件"></a>修改docker-compose文件</h3><pre><code>jaegertracing:
image: jaegertracing/all-in-one:latest
ports:
    - &quot;5775:5775/udp&quot;
    - &quot;6831:6831/udp&quot;
    - &quot;6832:6832/udp&quot;
    - &quot;5778:5778&quot;
    - &quot;16686:16686&quot;
    - &quot;14268:14268&quot;
command:
    - &quot;/go/bin/standalone-linux&quot;
    - &quot;--span-storage.type=elasticsearch&quot;
    - &quot;--query.static-files=/go/src/jaeger-ui-build/build/&quot;
environment:
    - SPAN_STORAGE_TYPE=elasticsearch
    - ES_SERVER_URLS=http://$DOCKERHOST:9200
</code></pre><h3 id="启动jaeger"><a href="#启动jaeger" class="headerlink" title="启动jaeger"></a>启动jaeger</h3><pre><code>docker-compose -f jaeger-start-docker.yaml up
</code></pre><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><img src="/2018/06/12/golang的OpenTracing和jeager使用/jaeger-es.png" title="启动成功">
<h3 id="补充几个es的查询语句"><a href="#补充几个es的查询语句" class="headerlink" title="补充几个es的查询语句"></a>补充几个es的查询语句</h3><ul>
<li><p>检查es状态<br>  curl <a href="http://127.0.0.1:9200" target="_blank" rel="noopener">http://127.0.0.1:9200</a></p>
</li>
<li><p>检查节点状态<br>  curl <a href="http://127.0.0.1:9200/_cat/health" target="_blank" rel="noopener">http://127.0.0.1:9200/_cat/health</a></p>
</li>
<li><p>查询某天的数据<br>  curl <a href="http://localhost:9200/jaeger-span-2018-06-14/_search" target="_blank" rel="noopener">http://localhost:9200/jaeger-span-2018-06-14/_search</a></p>
</li>
<li><p>查询数据数量<br>  curl <a href="http://localhost:9200/jaeger-span-\*/_count" target="_blank" rel="noopener">http://localhost:9200/jaeger-span-\*/_count</a></p>
</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/jaegertracing/jaeger-performance/blob/master/standalone/README.md" target="_blank" rel="noopener">jaeger test文档</a></p>
<p><a href="https://medium.com/opentracing/tracing-http-request-latency-in-go-with-opentracing-7cc1282a100a" target="_blank" rel="noopener">httptrace和opentracing</a></p>
<p><a href="https://www.jaegertracing.io/docs/getting-started/" target="_blank" rel="noopener">jaeger官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/golang的time-Time遇到的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/golang的time-Time遇到的坑/" itemprop="url">golang的time.Time遇到的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T23:20:53+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="坑的起源"><a href="#坑的起源" class="headerlink" title="坑的起源"></a>坑的起源</h2><p>使用不同的时区操作</p>
<h2 id="后端存储的时间戳数字"><a href="#后端存储的时间戳数字" class="headerlink" title="后端存储的时间戳数字"></a>后端存储的时间戳数字</h2><pre><code>// 入库操作
now := time.Now().Unix()
fmt.Println(now) // 2018-6-11 06:00:00 +0800 CST
db.Save(now)

// 查询操作
// 前端从时间框控件筛选时间(2018-6-11)，然后传至后端
startTime = 1528675200000
fmt.Println(startTime) // 2018-06-11 08:00:00 +0800 CST
// 错误出现 上面入库的数据因为是在6点(CST时区)入库，所以查询不到
</code></pre><h2 id="后端存储的是datetime类型"><a href="#后端存储的是datetime类型" class="headerlink" title="后端存储的是datetime类型"></a>后端存储的是datetime类型</h2><pre><code>t,_ := time.Parse(&quot;2006-01-02 15:04:05&quot;,&quot;2018-06-11 06:00:00&quot;) // UTC时区
db.Save(t)
</code></pre><h2 id="docker容器时区"><a href="#docker容器时区" class="headerlink" title="docker容器时区"></a>docker容器时区</h2><p>docker容器修改</p>
<h2 id="time-UnixNano-大于int64的最大值"><a href="#time-UnixNano-大于int64的最大值" class="headerlink" title="time.UnixNano() 大于int64的最大值"></a>time.UnixNano() 大于int64的最大值</h2><p>这个问题，标准包中已经说明了</p>
<pre><code>// UnixNano returns t as a Unix time, the number of nanoseconds elapsed
// since January 1, 1970 UTC. The result is undefined if the Unix time
// in nanoseconds cannot be represented by an int64 (a date before the year
// 1678 or after 2262). Note that this means the result of calling UnixNano
// on the zero Time is undefined.
func (t Time) UnixNano() int64 {
    return (t.unixSec())*1e9 + int64(t.nsec())
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>团队统一使用一个时区</li>
<li>不用time.Parse()，使用time.ParseInLocation()</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/优雅关闭的几种实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/优雅关闭的几种实现/" itemprop="url">优雅关闭的几种实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T09:43:07+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>等待进程处理完任务，关闭进程</p>
<h3 id="go1-8之后标准包实现优雅关闭"><a href="#go1-8之后标准包实现优雅关闭" class="headerlink" title="go1.8之后标准包实现优雅关闭"></a>go1.8之后标准包实现优雅关闭</h3><pre><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(5 * time.Second)
        fmt.Fprintf(w, &quot;Hello World, %v\n&quot;, time.Now())
        fmt.Println(&quot;hello:&quot;, time.Now())
    })

    s := &amp;http.Server{
        Addr:           &quot;:8080&quot;,
        Handler:        http.DefaultServeMux,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }

    go func() {
        log.Println(s.ListenAndServe())
        log.Println(&quot;server shutdown&quot;)
    }()

    // Handle SIGINT and SIGTERM.
    ch := make(chan os.Signal)
    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
    log.Println(&quot;ch:&quot;, &lt;-ch)

    // Stop the service gracefully.
    ctx := context.Background()
    log.Println(&quot;shut:&quot;, s.Shutdown(ctx))

    log.Println(&quot;done.&quot;)
}
</code></pre><h3 id="通过waitgroup实现"><a href="#通过waitgroup实现" class="headerlink" title="通过waitgroup实现"></a>通过waitgroup实现</h3><pre><code>参考beego.graceful.shutdown
</code></pre><h2 id="优雅重启"><a href="#优雅重启" class="headerlink" title="优雅重启"></a>优雅重启</h2><p>优雅关闭可以防止程序强制终止，导致的脏数据问题。但是在关闭到重启的期间，有一个真空期，用户的请求是不会被接收到的。优雅重启可以解决这类问题</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>fork子进程</li>
<li>父进程优雅关闭</li>
</ol>
<h3 id="通过共享listener，即socket文件，fork子进程"><a href="#通过共享listener，即socket文件，fork子进程" class="headerlink" title="通过共享listener，即socket文件，fork子进程"></a>通过共享listener，即socket文件，fork子进程</h3><pre><code>func forkAndRun(ln net.Listener) {
    l := ln.(*net.TCPListener)
    newFile, _ := l.File()

    cmd := exec.Command(os.Args[0], &quot;-graceful&quot;)
    cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr
    cmd.ExtraFiles = []*os.File{newFile}
    fmt.Printf(&quot;cmd:%#v&quot;, cmd)
    cmd.Run()
}
</code></pre><h3 id="fork子进程的时候，获取ppid，关闭父进程"><a href="#fork子进程的时候，获取ppid，关闭父进程" class="headerlink" title="fork子进程的时候，获取ppid，关闭父进程"></a>fork子进程的时候，获取ppid，关闭父进程</h3><pre><code>if graceful {
    process, err := os.FindProcess(os.Getppid())
    fmt.Println(&quot;ppid:&quot;, os.Getppid())
    if err != nil {
        log.Println(err)
        return err
    }
    err = process.Signal(syscall.SIGTERM)
    if err != nil {
        return err
    }
}
</code></pre><h3 id="160行代码实现一个graceful-server"><a href="#160行代码实现一个graceful-server" class="headerlink" title="160行代码实现一个graceful server"></a>160行代码实现一个graceful server</h3><pre><code>package mygrace

import (
    &quot;context&quot;
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

var (
    graceful bool
)

func init() {
    // 第一次启动时不要添加graceful，否则会报错
    flag.BoolVar(&amp;graceful, &quot;graceful&quot;, false, &quot;is graceful&quot;)
}

type Server struct {
    ln net.Listener
    *http.Server
    Done chan bool
}

func NewServer(addr string, handler http.Handler) (srv *Server) {
    if !flag.Parsed() {
        flag.Parse()
    }
    srv = &amp;Server{Done: make(chan bool)}
    hsrv := &amp;http.Server{
        Addr:           addr,
        Handler:        handler,
        ReadTimeout:    10 * time.Second, // 值如果过小，会导致client端读取resp失败
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }
    srv.Server = hsrv
    return
}

// 这里addr可以不用传，因为下面
func ListenAndServe(addr string, handler http.Handler) error {
    s := NewServer(addr, handler)
    err := s.ListenAndServe()
    return err
}

func (srv *Server) ListenAndServe() error {
    // 这里获取listener
    // 如果是第一次启动，是从net.Listen获取
    // 其余情况，是根据文件描述符获取
    ln, err := srv.getListener()
    if err != nil {
        log.Println(&quot;srv.getListener():&quot;, err)
        return err
    }
    srv.ln = ln

    if graceful {
        process, err := os.FindProcess(os.Getppid())
        log.Println(&quot;ppid:&quot;, os.Getppid())
        if err != nil {
            log.Println(err)
            return err
        }
        err = process.Signal(syscall.SIGTERM)
        if err != nil {
            return err
        }
    }
    log.Println(os.Getpid(), srv.Addr)
    go srv.Serve(srv.ln)
    go srv.handleSignals()
    &lt;-srv.Done
    log.Println(&quot;srv done!!!&quot;)
    return nil
}

func (srv *Server) shutdown() error {
    ctx := context.Background()
    err := srv.Shutdown(ctx)
    srv.Done &lt;- true
    return err
}

func (srv *Server) fork() error {

    tl := srv.ln.(*net.TCPListener)
    file, err := tl.File()
    if err != nil {
        log.Println(&quot;ln.File() err:&quot;, err)
        return err
    }

    cmd := exec.Command(os.Args[0], &quot;-graceful&quot;)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Stdin = os.Stdin
    cmd.ExtraFiles = []*os.File{file}
    err = cmd.Start()
    if err != nil {
        log.Fatalf(&quot;Restart: Failed to launch, error: %v&quot;, err)
    }
    return nil
}

func (srv *Server) handleSignals() {
    for {
        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)

        sigMsg := &lt;-sig
        switch sigMsg {
        case syscall.SIGHUP:
            log.Println(&quot;receive syscall.SIGHUP&quot;)
            err := srv.fork()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
        case syscall.SIGINT:
            log.Println(&quot;receive syscall.SIGINT&quot;)
            err := srv.shutdown()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
            return
        case syscall.SIGTERM:
            log.Println(&quot;receive syscall.SIGTERM&quot;)
            err := srv.shutdown()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
            return
        }
    }
    return
}

func (srv *Server) getListener() (l net.Listener, err error) {
    if graceful {
        f := os.NewFile(uintptr(3), &quot;&quot;)
        l, err = net.FileListener(f)
        if err != nil {
            err = fmt.Errorf(&quot;net.FileListener error: %v&quot;, err)
            return
        }
    } else {
        l, err = net.Listen(&quot;tcp&quot;, srv.Addr)
        if err != nil {
            err = fmt.Errorf(&quot;net.Listen error: %v&quot;, err)
            return
        }
    }
    return
}
</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>在分布式的环境下，有必要优雅重启吗？<br>虽然分布式环境可以避免用户请求的真空期，但是还是会可能产生脏数据。</p>
</li>
<li><p>有时候出现服务端执行完成，但是客户端读取response失败？<br>也许可以尝试：在服务端初始化http.Server的时候，可以把ReadTimeout，WriteTimeout时间调长一点</p>
</li>
<li><p>beego的grace正确使用姿势？<br>在配置文件中，Graceful设置为true，重启时使用kill -1 xxx来结束程序。另外第一次执行程序时不要加参数 -graceful=true，否则getListener会因为查找listener失败的，并且因为这个时候程序的ppid为1，是没有权限杀死的，beego这一块没有做错误处理。</p>
</li>
<li><p>os.FindProcess(os.Getppid()) 查出来的ppid等于1？<br>有两种可能，1.直接调用了-graceful参数；2.find的时候父进程已经结束，该进程会转移为1下面的子进程</p>
</li>
<li><p>getListener方法中，为什么根据 os.NewFile(uintptr(3), “”) 就能获取之前的socket文件？<br>有待研究</p>
</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://jiajunhuang.com/articles/2017_10_25-golang_graceful_restart.md.html" target="_blank" rel="noopener">Golang实现平滑重启(优雅重启)</a></p>
<p><a href="https://github.com/astaxie/beego/tree/master/grace" target="_blank" rel="noopener">beego的graceful实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/golang实现ECC加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/golang实现ECC加密/" itemprop="url">golang实现ECC加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T10:46:39+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上.</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。</p>
<p>椭圆曲线依赖的数学难题是:</p>
<pre><code>k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知q和P，很难计算出k
</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>golang 标准包中直接提供了密钥生成的方法</p>
<pre><code>// 初始化椭圆曲线
pubkeyCurve := elliptic.P256()
// 随机挑选基点,生成私钥
p, err := ecdsa.GenerateKey(pubkeyCurve, rand.Reader)
if err != nil {
    fmt.Println(&quot;1&quot;, err)
    os.Exit(1)
}
PRIVATE = p
</code></pre><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>golang标准包中没有提供加密和解密算法,但是以太坊go-ethereum实现了相关算法,这里对其进行二次封装</p>
<pre><code>// 将标准包生成私钥转化为ecies私钥
prv2 = ecies.ImportECDSA(PRIVATE)
// ecc(ecies)加密
func ECCEncrypt(pt []byte) ([]byte, error) {
    ct, err := ecies.Encrypt(rand.Reader, &amp;prv2.PublicKey, pt, nil, nil)
    return ct, err
}
// ecc(ecies)解密
func ECCDecrypt(ct []byte) ([]byte, error) {
    pt, err := prv2.Decrypt(ct, nil, nil)
    return pt, err
}
</code></pre><h2 id="签名和验签"><a href="#签名和验签" class="headerlink" title="签名和验签"></a>签名和验签</h2><p>golang标准包中提供了相关方法</p>
<pre><code>func EccSign(pt []byte) (sign []byte, err error) {
    // 根据明文plaintext和私钥，生成两个big.Ing
    r, s, err := ecdsa.Sign(rand.Reader, PRIVATE, pt)
    if err != nil {
        fmt.Println(err)
        return nil, err
    }
    rs, err := r.MarshalText()
    if err != nil {
        return nil, err
    }
    ss, err := s.MarshalText()
    if err != nil {
        return nil, err
    }
    // 将r，s合并（以“+”分割），作为签名返回
    var b bytes.Buffer
    b.Write(rs)
    b.Write([]byte(`+`))
    b.Write(ss)
    return b.Bytes(), nil
}

func EccSignVer(pt, sign []byte) bool {
    var rint, sint big.Int
    // 根据sign，解析出r，s
    rs := bytes.Split(sign, []byte(&quot;+&quot;))
    rint.UnmarshalText(rs[0])
    sint.UnmarshalText(rs[1])
    // 根据公钥，明文，r，s验证签名
    v := ecdsa.Verify(&amp;PRIVATE.PublicKey, pt, &amp;rint, &amp;sint)
    return v
}
</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="ECC-ECIES-ECDSA-ECDH-是什么关系-有哪些区别"><a href="#ECC-ECIES-ECDSA-ECDH-是什么关系-有哪些区别" class="headerlink" title="ECC,ECIES,ECDSA,ECDH 是什么关系,有哪些区别?"></a>ECC,ECIES,ECDSA,ECDH 是什么关系,有哪些区别?</h3><ul>
<li>ECC,全称椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC）,主要是指相关数学原理</li>
<li>ECIES,在ECC原理的基础上实现的一种公钥加密方法,和RSA类似</li>
<li>ECDSA,在ECC原理上实现的签名方法</li>
<li>ECDH在ECC和DH的基础上实现的密钥交换算法</li>
</ul>
<h3 id="RSA算法的密钥对可以通过-pem文件来保存-ECC的密钥对要如何保存呢"><a href="#RSA算法的密钥对可以通过-pem文件来保存-ECC的密钥对要如何保存呢" class="headerlink" title="RSA算法的密钥对可以通过.pem文件来保存,ECC的密钥对要如何保存呢?"></a>RSA算法的密钥对可以通过.pem文件来保存,ECC的密钥对要如何保存呢?</h3><p>go-ethereum提供了两种对外接口.</p>
<p>密钥对和[]byte之间的转换</p>
<pre><code>// 私钥 -&gt; []byte
// FromECDSA exports a private key into a binary dump.
func FromECDSA(priv *ecdsa.PrivateKey) []byte {
    if priv == nil {
        return nil
    }
    return math.PaddedBigBytes(priv.D, priv.Params().BitSize/8)
}

// []byte -&gt; 私钥
// ToECDSA creates a private key with the given D value.
func ToECDSA(d []byte) (*ecdsa.PrivateKey, error) {
    return toECDSA(d, true)
}

// 公钥 -&gt; []byte
func FromECDSAPub(pub *ecdsa.PublicKey) []byte {
    if pub == nil || pub.X == nil || pub.Y == nil {
        return nil
    }
    return elliptic.Marshal(S256(), pub.X, pub.Y)
}

// []byte -&gt; 公钥
    func ToECDSAPub(pub []byte) *ecdsa.PublicKey {
    if len(pub) == 0 {
        return nil
    }
    x, y := elliptic.Unmarshal(S256(), pub)
    return &amp;ecdsa.PublicKey{Curve: S256(), X: x, Y: y}
}
</code></pre><p><strong>公钥转换的时候需要注意,eth中默认使用的椭圆曲线是S256().生成密钥对时,如果使用的是其他椭圆曲线(如P256),需要对FromECDSAPub,ToECDSAPub稍作修改</strong></p>
<p>密钥对和文件之间的转换,其实就是在中间加一层hex编码</p>
<pre><code>// 私钥 -&gt; 文件
// SaveECDSA saves a secp256k1 private key to the given file with
// restrictive permissions. The key data is saved hex-encoded.
func SaveECDSA(file string, key *ecdsa.PrivateKey) error {
    k := hex.EncodeToString(FromECDSA(key))
    return ioutil.WriteFile(file, []byte(k), 0600)
}

// 文件 -&gt; 私钥
func LoadECDSA(file string) (*ecdsa.PrivateKey, error) {
    buf := make([]byte, 64)
    fd, err := os.Open(file)
    if err != nil {
        return nil, err
    }
    defer fd.Close()
    if _, err := io.ReadFull(fd, buf); err != nil {
        return nil, err
    }

    key, err := hex.DecodeString(string(buf))
    if err != nil {
        return nil, err
    }
    return ToECDSA(key)
}
</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://zhuanlan.zhihu.com/p/35225057" target="_blank" rel="noopener">椭圆曲线数学原理 (上篇)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35587405" target="_blank" rel="noopener">椭圆曲线数学原理 (下篇)</a></p>
<p><a href="https://crypto.stackexchange.com/questions/12823/ecdsa-vs-ecies-vs-ecdh" target="_blank" rel="noopener">ECIES,ECDSA,ECDH三者的区别</a></p>
<p><a href="https://github.com/ethereum/go-ethereum/tree/master/crypto/ecies" target="_blank" rel="noopener">以太坊ecies实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/05/golang实现RSA加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/golang实现RSA加密/" itemprop="url">golang实现RSA加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T09:38:14+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1976年之前，所有加密方式都是同一种模式：甲乙双方使用同一种加密算法和密钥，即对称加密。这种模式有一个弱点：甲方必须先把加密规则和密钥告诉乙方。这样导致保存和传递密钥，成为了一个头疼的问题。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman密钥交换算法”。这个算法启发了其他科学家。人们认识到，<strong>加密和解密可以使用不同的密钥</strong>，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p>这种新的加密模式被称为”非对称加密算法”。</p>
<p>RSA是非对称加密中的一种。</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>大整数的因数分解，是一件非常困难的事情。例如你可以对3233进行因数分解（61×53），但对较大整数进行因数分解就比较困难了。</p>
<p>这里提供一个golang实现的暴力因数分解，有兴趣可以跑一下试试：</p>
<pre><code>// 因数分解
// 因为大整数s可能会超过uint64的最大值，所以这里用字符串来作为输入参数
func factorization(s string) (x, y *big.Int, err error) {
    df := big.NewInt(1)
    x = big.NewInt(2)
    n, flag := big.NewInt(1).SetString(s, 0)
    if !flag {
        return nil, nil, errors.New(&quot;invalid string&quot;)
    }
    for ; x.Cmp(n) == -1; x.Add(x, big.NewInt(1)) {
        fmt.Println(&quot;x:&quot;, x.String())
        if df.Mod(n, x).String() == &quot;0&quot; {
            return x, df.Div(n, x), nil
        }
    }
    return nil, nil, errors.New(&quot;end faild&quot;)
}
</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>A想与B进行加密通信，首先要生成一个密钥：</p>
<ol>
<li><p>A选择两个大质数，得到乘积n，再随机选择一个整数e，计算e对于φ(n)的模反元素d。</p>
</li>
<li><p>将（n，e）作为公钥，（n，d）作为私钥</p>
</li>
</ol>
<p>可以证明，如果想通过公钥获取私钥，难度取决于大整数因数分解的效率。</p>
<p>关于模反元素和相关推导，可以看<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">链接</a>，比想象中简单</p>
<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p>B想给A发送信息m</p>
<ol>
<li><p>将m转化为整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
</li>
<li><p>根据公式<br> m^e ≡ c (mod n)<br>已知m（明文），e（公钥的一部分），n（公钥的一部分），可以得到密文c</p>
</li>
</ol>
<h3 id="私钥解密"><a href="#私钥解密" class="headerlink" title="私钥解密"></a>私钥解密</h3><ol>
<li><p>得到密文c</p>
</li>
<li><p>根据公式<br> c^d ≡ m (mod n)<br>已知 c（密文），d（私钥的一部分），n（私钥的一部分），可以得到明文m</p>
</li>
</ol>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">证明根据根据以上公式获取的明文和原始明文一致</a></p>
<h2 id="golang代码实现RSA密钥生成"><a href="#golang代码实现RSA密钥生成" class="headerlink" title="golang代码实现RSA密钥生成"></a>golang代码实现RSA密钥生成</h2><pre><code>//生成公钥和私钥 pem文件

package encryp

import (
    &quot;crypto/rand&quot;
    &quot;crypto/rsa&quot;
    &quot;crypto/x509&quot;
    &quot;encoding/pem&quot;
    &quot;os&quot;
)

//生成 私钥和公钥文件
func GenRsaKey(bits int) error {
    //生成私钥文件
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return err
    }
    derStream := x509.MarshalPKCS1PrivateKey(privateKey)
    block := &amp;pem.Block{
        Type:  &quot;RSA PRIVATE KEY&quot;,
        Bytes: derStream,
    }
    file, err := os.Create(&quot;private.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(file, block)
    if err != nil {
        return err
    }
    //生成公钥文件
    publicKey := &amp;privateKey.PublicKey
    defPkix, err := x509.MarshalPKIXPublicKey(publicKey)
    if err != nil {
        return err
    }
    block = &amp;pem.Block{
        Type:  &quot;RSA PUBLIC KEY&quot;,
        Bytes: defPkix,
    }
    file, err = os.Create(&quot;public.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(file, block)
    if err != nil {
        return err
    }
    return nil
}
</code></pre><h2 id="golang实现RSA加密和解密"><a href="#golang实现RSA加密和解密" class="headerlink" title="golang实现RSA加密和解密"></a>golang实现RSA加密和解密</h2><pre><code>// 读取公钥私钥
var privateKey, publicKey []byte
func init() {
    var err error
    publicKey, err = ioutil.ReadFile(&quot;public.pem&quot;)
    if err != nil {
        os.Exit(-1)
    }
    privateKey, err = ioutil.ReadFile(&quot;private.pem&quot;)
    if err != nil {
        os.Exit(-1)
    }
}

// 公钥加密
func RsaEncrypt(data []byte) ([]byte, error) {
    //解密pem格式的公钥
    block, _ := pem.Decode(publicKey)
    if block == nil {
        return nil, errors.New(&quot;public key error&quot;)
    }
    // 解析公钥
    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 类型断言
    pub := pubInterface.(*rsa.PublicKey)
    //加密
    return rsa.EncryptPKCS1v15(rand.Reader, pub, data)
}

// 私钥解密
func RsaDecrypt(ciphertext []byte) ([]byte, error) {
    //获取私钥
    block, _ := pem.Decode(privateKey)
    if block == nil {
        return nil, errors.New(&quot;private key error!&quot;)
    }
    //解析PKCS1格式的私钥
    priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 解密
    return rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)
}
</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理-欧拉函数</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/golang实现AES加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/golang实现AES加密/" itemprop="url">golang实现AES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T18:48:36+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h2><p>AES加密算法（Advanced Encryption Standard）：是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><ol>
<li>根据初始密钥长度（16，24，32）进行扩展，执行AES-128, AES-192, AES-256算法</li>
</ol>
<h3 id="明文加密-解密"><a href="#明文加密-解密" class="headerlink" title="明文加密/解密"></a>明文加密/解密</h3><p>主要包括四个子程序：</p>
<ol>
<li><p>字节替代(SubBytes):<br>矩阵中的各字节通过一个8位的S-box（Inverse S-box）进行转换</p>
</li>
<li><p>行移位(ShiftRows)<br>第n行向左（右）移动n-1位，n从1开始</p>
</li>
<li><p>列混淆(MixColumns)<br>每一列都在modulox^4+1之下，和一个固定多项式c(x)作乘法。</p>
</li>
<li><p>轮密钥加(AddRoundKey)<br>将每个状态中的字节与<strong>该回合</strong>密钥做异或运算。</p>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>func AesEncrypt(origData, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    blockSize := block.BlockSize()
    origData = PKCS5Padding(origData, blockSize)
    blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])
    crypted := make([]byte, len(origData))
    blockMode.CryptBlocks(crypted, origData)
    return crypted, nil
}

func AesDecrypt(crypted, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    blockSize := block.BlockSize()
    blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])
    origData := make([]byte, len(crypted))
    blockMode.CryptBlocks(origData, crypted)
    origData = PKCS5UnPadding(origData)
    return origData, nil
}
</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>字节替代中，Forward S-box，Inverse S-box 构造过程？是否与密钥或者明文相关？<br>S盒的构造方式如下：<br>（1） 按字节值得升序逐行初始化S盒。在行y列x的字节值是{yx}。<br>（2） 把S盒中的每个字节映射为它在有限域GF中的逆;{00}映射为它自身{00}。<br>（3） 把S盒中的每个字节的8个构成位记为(b7, b6, b5, b4, b3, b2, b1)。对S盒的每个字节的每个位做如下的变换：</p>
</li>
<li><p>列混淆中，加密与解密的多项式如何构造</p>
</li>
<li><p>轮密钥加，每个回合的密钥如何生成的</p>
</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.jianshu.com/p/436e82a3a91a" target="_blank" rel="noopener">AES加密算法和RSA加密算法</a><br><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86" target="_blank" rel="noopener">wiki</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/golang实现DES加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/golang实现DES加密/" itemprop="url">golang实现DES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T11:35:28+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DES简介"><a href="#DES简介" class="headerlink" title="DES简介"></a>DES简介</h2><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。</p>
<h3 id="概念隐喻"><a href="#概念隐喻" class="headerlink" title="概念隐喻"></a>概念隐喻</h3><ul>
<li>加密 - 做蛋糕</li>
<li>明文 - 原材料</li>
<li>IV初始向量 - 厨师. IV长度必须与block.Size保持一致. 维基百科上说重复使用IV会导致安全隐患</li>
<li>block - 一套工具</li>
<li>工作模式 - 工具使用说明书,有EBC,CBC等</li>
<li>Padding填充模式 - 检查原材料.块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的.因此部分模式（即ECB和CBC）需要最后一块在加密前进行填充</li>
</ul>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程:"></a>加密过程:</h3><ul>
<li>block = 密钥切割</li>
<li>pdata = padding + data</li>
<li>加密算法 = 工作模式+初始向量+block 代码:cipher.NewCBCEncrypter(block,iv)</li>
<li>密文 = 加密算法 + pdata </li>
</ul>
<h3 id="解密过程-解密算法其实是对密文的加密"><a href="#解密过程-解密算法其实是对密文的加密" class="headerlink" title="解密过程(解密算法其实是对密文的加密)"></a>解密过程(解密算法其实是对密文的加密)</h3><ul>
<li>block = 密钥切割</li>
<li>解密算法 = 工作模式+初始向量+block 代码:cipher.NewCBCDecrypter(block,iv)</li>
<li>明文padding = 解密算法 + 密文</li>
<li>明文 = unpadding + 明文padding</li>
</ul>
<p>EBC(Electronic codebook)和CBC(Cipher-block Chain)的比较:</p>
<ul>
<li>EBC 同样的明文块会被加密成相同的密文块.</li>
<li>CBC 每个明文块先与前一个密文块进行异或后，再进行加密.</li>
<li>安全强度上CBC更强</li>
<li>CBC无法并行加密</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>// DES加密
func DesEncrypt(origData, key []byte) ([]byte, error) {
    // 根据密钥生成block
    block, err := des.NewCipher(key)
    if err != nil {
        return nil, err
    }
    // 根据block和初始向量生成加密算法,IV长度与block.size需要保持一致
    blockMode := cipher.NewCBCEncrypter(block, IV)
    // 扩充 origData
    origData = PKCS5Padding(origData, block.BlockSize())
    crypted := make([]byte, len(origData))
    // 对padded data加密
    blockMode.CryptBlocks(crypted, origData)
    return crypted, nil
}

// DES解密
func DesDecrypt(crypted, key []byte) ([]byte, error) {
    // 根据密钥生成block
    block, err := des.NewCipher(key)
    if err != nil {
        return nil, err
    }
    // 根据block和初始向量生成解密算法,IV长度与block.size需要保持一致
    blockMode := cipher.NewCBCDecrypter(block, IV)
    // 对密文解密
    origData := make([]byte, len(crypted))
    blockMode.CryptBlocks(origData, crypted)
    // 反扩充,获取原始明文
    origData = PKCS5UnPadding(origData)
    return origData, nil
}
</code></pre><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接:"></a>相关链接:</h3><p><a href="https://www.jianshu.com/p/c44a8a1b7c38" target="_blank" rel="noopener">DES加密算法原理</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工作模式 ECB,CBC</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/关于加密算法的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/关于加密算法的理解/" itemprop="url">关于加密算法的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T21:43:24+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul>
<li>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。</li>
<li>3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li>
<li>AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</li>
</ul>
<p>总结(相同数据,相同密钥):</p>
<ol>
<li>DES速度是3DES的三倍</li>
<li>AES分为根据密钥长度分为AES-128,AES-192,AES-256,三者性能差别不大</li>
<li>AES性能优于DES</li>
</ol>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul>
<li>RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；</li>
<li>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）；</li>
<li>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码学。</li>
</ul>
<p>总结: </p>
<ol>
<li>RSA随着密钥对的长度增长,加解密速度会明显降低</li>
<li>目前还没实现</li>
<li><p>目前还没实现,但是根据ECC签名以及网上的资料表示,ECC会逐渐成为主流</p>
<p> 对称加密,非对称加密的前提条件都是要先生成密钥或者密钥对</p>
</li>
</ol>
<h2 id="哈系算法"><a href="#哈系算法" class="headerlink" title="哈系算法"></a>哈系算法</h2><ul>
<li>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法。</li>
<li>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值；</li>
</ul>
<p>总结: </p>
<ol>
<li>SHA比MD5复杂强度更高,但是运行速度较慢.</li>
<li>哈系算法一般会结合非对称加密,实现签名-验签</li>
</ol>
<h2 id="签名-验签"><a href="#签名-验签" class="headerlink" title="签名-验签"></a>签名-验签</h2><ul>
<li>RSA+hash(sha,mad5)</li>
<li>ECC</li>
</ul>
<h2 id="加密-解密-和-签名-验签的区别"><a href="#加密-解密-和-签名-验签的区别" class="headerlink" title="加密/解密 和 签名/验签的区别"></a>加密/解密 和 签名/验签的区别</h2><ol>
<li>一般都使用非对称加密</li>
<li>前者使用公钥加密,私钥解密</li>
<li>后者使用私钥签名,公钥验签</li>
<li>签名/验签的过程不一定需要反向解密</li>
</ol>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p><a href="https://zhuanlan.zhihu.com/p/35225057" target="_blank" rel="noopener">椭圆曲线加密教程 (上篇)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35587405" target="_blank" rel="noopener">椭圆曲线加密教程 (下篇)</a></p>
<p><a href="https://blog.csdn.net/qq_21794823/article/details/53114819" target="_blank" rel="noopener">常见加密算法分类,用途,原理以及比较</a></p>
<p>目前只是研究了ECC算法原理,但是理解上还差一点,后期补上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/代码大全-阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/代码大全-阅读笔记/" itemprop="url">代码大全-阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T09:46:27+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做过很多需求.每次需求过来,稍微分析一下就开始建表写代码.两年下来,总感觉对开发流程,代码规范的认知缺少深度,这里想通过阅读<strong>代码大全</strong>这本经典,对自己做一次总结.</p>
<h2 id="什么是软件构建"><a href="#什么是软件构建" class="headerlink" title="什么是软件构建"></a>什么是软件构建</h2><h3 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h3><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="规划构建"><a href="#规划构建" class="headerlink" title="规划构建"></a>规划构建</h3><h3 id="高层设计"><a href="#高层设计" class="headerlink" title="高层设计"></a>高层设计</h3><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><h3 id="编码与调试"><a href="#编码与调试" class="headerlink" title="编码与调试"></a>编码与调试</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><h3 id="保障维护"><a href="#保障维护" class="headerlink" title="保障维护"></a>保障维护</h3><hr>
<h2 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h2><p>写作,代价是丢掉一张草稿</p>
<p>培育,软件开发相当于系统生长,骨架-肌肉-皮肤,增量式开发.</p>
<p>建造, 定义问题-设计(线路)-审查(质检)</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>有些人断言,前期准备毫无用处.</p>
<p>前期准备不周全的原因:</p>
<ol>
<li>不具备相关规划技能.学习</li>
<li>尽快编码的欲望.总结之前的项目痛点</li>
</ol>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>问题定义只定义了问题是什么,而不涉及任何可能的解决方案</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>为什么会有变更?</p>
<p>随着客户参与项目的时间增长,他们对项目的理解也就越深.</p>
<p>平均情况,25%的需求会有变化.特殊情况,75%-85%的需求变更</p>
<h2 id="架构的组成部分"><a href="#架构的组成部分" class="headerlink" title="架构的组成部分"></a>架构的组成部分</h2><h3 id="程序组织-Programma-Organization"><a href="#程序组织-Programma-Organization" class="headerlink" title="程序组织 Programma Organization"></a>程序组织 Programma Organization</h3><h3 id="主要的类-Major-Classes"><a href="#主要的类-Major-Classes" class="headerlink" title="主要的类 Major Classes"></a>主要的类 Major Classes</h3><p>80/20法则:对哪些构成系统80%的行为的20%的类进行详细说明</p>
<h3 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h3><p>数据通常只应该由一个子系统或者一个类直接访问</p>
<h3 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h3><h3 id="用户界面设计"><a href="#用户界面设计" class="headerlink" title="用户界面设计"></a>用户界面设计</h3><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><h3 id="互用性"><a href="#互用性" class="headerlink" title="互用性"></a>互用性</h3><h3 id="国际化-本地化"><a href="#国际化-本地化" class="headerlink" title="国际化/本地化"></a>国际化/本地化</h3><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>%90的代码用来处理异常情况,10%的代码处理常规情况</p>
<p>一般被认为是代码约定层次的事情</p>
<p>以下是关于错误处理需要考虑的事情:</p>
<ul>
<li>进行纠正还是检测?</li>
<li>检测是主动还是被动?</li>
<li>如果传播错误?</li>
<li>错误消息的处理有什么约定?</li>
<li>如何处理异常?记录或者描述</li>
<li>每个类在验证输入数据的有效性方面,需要负何种责任?每个类都验证,还是有一个类负责验证整个系统的数据有效性?</li>
<li>使用运行环境的错误处理机制,还是自己建立一套?</li>
</ul>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>容错策略:</p>
<ul>
<li>检测到错误退回去,退回到之前一切正常的时刻,从该点继续运行</li>
<li>切换到另外一套辅助程序</li>
<li>表决算法</li>
<li>使用默认值代替错误值</li>
<li>遇到错误时,进入”部分运转”的状态</li>
</ul>
<h3 id="架构的可行性"><a href="#架构的可行性" class="headerlink" title="架构的可行性"></a>架构的可行性</h3><h3 id="过度工程"><a href="#过度工程" class="headerlink" title="过度工程"></a>过度工程</h3><h3 id="买还是造"><a href="#买还是造" class="headerlink" title="买还是造"></a>买还是造</h3><h3 id="关于复用的决策"><a href="#关于复用的决策" class="headerlink" title="关于复用的决策"></a>关于复用的决策</h3><h3 id="变更策略"><a href="#变更策略" class="headerlink" title="变更策略"></a>变更策略</h3><p>表驱动技术</p>
<h3 id="架构的总体质量"><a href="#架构的总体质量" class="headerlink" title="架构的总体质量"></a>架构的总体质量</h3><p>你,作为一个实现该系统的程序员,是否对这个架构感觉良好?</p>
<h2 id="构建中的设计"><a href="#构建中的设计" class="headerlink" title="构建中的设计"></a>构建中的设计</h2><p>设计是一个险恶(wicked)的问题,wicked指的是你必须把这个问题”解决”一遍,才能明确地定义它,然后再次解决该问题,从而形成一个可行的方案.</p>
<h2 id="关键的设计概念"><a href="#关键的设计概念" class="headerlink" title="关键的设计概念"></a>关键的设计概念</h2><h3 id="设计的难题主要包括偶然的难题和本质的难题"><a href="#设计的难题主要包括偶然的难题和本质的难题" class="headerlink" title="设计的难题主要包括偶然的难题和本质的难题"></a>设计的难题主要包括偶然的难题和本质的难题</h3><h3 id="管理复杂度"><a href="#管理复杂度" class="headerlink" title="管理复杂度"></a>管理复杂度</h3><h4 id="复杂度原因"><a href="#复杂度原因" class="headerlink" title="复杂度原因"></a>复杂度原因</h4><ul>
<li>用复杂的方法解决简单的问题</li>
<li>用简单但错误的方法解决复杂的问题</li>
<li>用正确但复杂的问题解决复杂的问题</li>
</ul>
<h4 id="应对复杂度"><a href="#应对复杂度" class="headerlink" title="应对复杂度"></a>应对复杂度</h4><ul>
<li>最小复杂度 避免做出”聪明的设计”,应该做出简单且易于理解的设计</li>
<li>易于维护 为其他程序员着想</li>
<li>松散耦合 设计出关联尽可能少的类</li>
<li>可扩展性</li>
<li>可重用性</li>
<li>高扇入(被利用) 让大量的类使用某个子类</li>
<li>低扇出 少量或适中地使用其他的类(7个以下)</li>
<li>精简性 一本书的完成,不在他不能再加入任何内容的时候,而在不能再删去任何内容的时候</li>
<li>层次性</li>
<li>标准技术</li>
</ul>
<h3 id="设计的层次"><a href="#设计的层次" class="headerlink" title="设计的层次"></a>设计的层次</h3><ul>
<li>子系统或者包 子系统之间的调用,应该是无环图</li>
<li>分解为类</li>
<li>分解为子程序</li>
<li>子程序内部的设计</li>
</ul>
<h3 id="找出容易改变的区域"><a href="#找出容易改变的区域" class="headerlink" title="找出容易改变的区域"></a>找出容易改变的区域</h3><h4 id="对变化的预期能力"><a href="#对变化的预期能力" class="headerlink" title="对变化的预期能力"></a>对变化的预期能力</h4><ul>
<li>找出看起来容易变化的项目</li>
<li>把容易变化的项目分离出来</li>
<li>把看起来容易变化的项目隔离开来</li>
</ul>
<h4 id="容易变化的区域"><a href="#容易变化的区域" class="headerlink" title="容易变化的区域"></a>容易变化的区域</h4><ul>
<li>业务规则</li>
<li>对硬件的依赖性</li>
<li>输入和输出</li>
<li>非标准的语言特性</li>
<li>困难的设计区域和构建区域</li>
<li>状态变量</li>
<li>常量</li>
</ul>
<h3 id="耦合标准"><a href="#耦合标准" class="headerlink" title="耦合标准"></a>耦合标准</h3><p>尽可能缩减相互连接</p>
<h3 id="耦合的种类"><a href="#耦合的种类" class="headerlink" title="耦合的种类"></a>耦合的种类</h3><h4 id="简单数据参数耦合"><a href="#简单数据参数耦合" class="headerlink" title="简单数据参数耦合"></a>简单数据参数耦合</h4><h4 id="简单对象耦合"><a href="#简单对象耦合" class="headerlink" title="简单对象耦合"></a>简单对象耦合</h4><h4 id="对象参数耦合"><a href="#对象参数耦合" class="headerlink" title="对象参数耦合"></a>对象参数耦合</h4><h4 id="语义上的耦合-使用潜在的耦合假设-危险"><a href="#语义上的耦合-使用潜在的耦合假设-危险" class="headerlink" title="语义上的耦合,使用潜在的耦合假设,危险"></a>语义上的耦合,使用潜在的耦合假设,危险</h4><p>类和子程序适用于降低复杂度的首选和最重要的智力工具,如果他们没帮助你简化工作,那么他们就是失职的</p>
<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><p>设计模式是一种非常强大的管理复杂度的工具</p>
<p>但同时也存在一个潜在的陷阱:”为了模式而模式”,有时候对代码进行一些微小的改动,以符合某个广为人知的模式,会使这段代码更容易理解.</p>
<p>但是如果一段代码做出巨大改动,迫使它去符合某个标准模式,有时反而会把问题复杂化</p>
<h3 id="数学领域的解题思路"><a href="#数学领域的解题思路" class="headerlink" title="数学领域的解题思路"></a>数学领域的解题思路</h3><ul>
<li>理解问题,未知量,现有数据,条件分别是什么.现有数据是否足够,或者不够</li>
<li>再次之前你遇到过这个问题吗,或者类似的问题.</li>
<li>盯住未知量,试着想出一个有着相同或者类似未知量的问题来</li>
<li>现在能重述这个问题吗,用之前不同的方式重述</li>
<li>如果还是解决不了,试着先去解决一些相关的问题,一个更一般,或者更特殊,或者问题的一部分</li>
<li>设计一个计划,找出现有数据和未知量的联系</li>
<li>执行这一计划,能否检查每一步,并证明他是正确的</li>
<li>回顾整个解</li>
</ul>
<h2 id="前期要做多少设计才够"><a href="#前期要做多少设计才够" class="headerlink" title="前期要做多少设计才够"></a>前期要做多少设计才够</h2><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/git.png"
                alt="Yh Zhang" />
            
              <p class="site-author-name" itemprop="name">Yh Zhang</p>
              <p class="site-description motion-element" itemprop="description">See you again</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yh Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
