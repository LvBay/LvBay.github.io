<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="See you again">
<meta property="og:type" content="website">
<meta property="og:title" content="Z">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Z">
<meta property="og:description" content="See you again">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Z">
<meta name="twitter:description" content="See you again">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Z</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Z</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/mysql事务与锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/mysql事务与锁/" itemprop="url">mysql事务与锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T18:20:16+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a>mysql事务</h1><h2 id="什么是mysql事务"><a href="#什么是mysql事务" class="headerlink" title="什么是mysql事务"></a>什么是mysql事务</h2><p>数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作。</p>
<p>事务是一组不可再分割的操作单元</p>
<h3 id="哪些存储引擎支持事务"><a href="#哪些存储引擎支持事务" class="headerlink" title="哪些存储引擎支持事务"></a>哪些存储引擎支持事务</h3><p>innodb myisam</p>
<h3 id="update-xxx-set-xxx-xxx-where-xxx-有事务吗"><a href="#update-xxx-set-xxx-xxx-where-xxx-有事务吗" class="headerlink" title="update xxx set xxx = xxx where xxx=? 有事务吗"></a>update xxx set xxx = xxx where xxx=? 有事务吗</h3><p>有。通过会话层autocommit变量来控制，默认自动提交</p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>原子性，一致性，隔离性，持久性</p>
<h2 id="事务并发的三个问题"><a href="#事务并发的三个问题" class="headerlink" title="事务并发的三个问题"></a>事务并发的三个问题</h2><h3 id="脏读-多个事务并发，导致脏读"><a href="#脏读-多个事务并发，导致脏读" class="headerlink" title="脏读:多个事务并发，导致脏读"></a>脏读:多个事务并发，导致脏读</h3><table>
<thead>
<tr>
<th>r1</th>
<th>r2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>update</td>
</tr>
<tr>
<td>read（脏读）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>rollback</td>
</tr>
</tbody>
</table>
<h3 id="不可重复读-一个事务的前后两次读取之间，有其他事务对数据做了修改，导致两次读取数据不一致"><a href="#不可重复读-一个事务的前后两次读取之间，有其他事务对数据做了修改，导致两次读取数据不一致" class="headerlink" title="不可重复读:一个事务的前后两次读取之间，有其他事务对数据做了修改，导致两次读取数据不一致"></a>不可重复读:一个事务的前后两次读取之间，有其他事务对数据做了修改，导致两次读取数据不一致</h3><table>
<thead>
<tr>
<th>r1</th>
<th>r2</th>
</tr>
</thead>
<tbody>
<tr>
<td>read</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update</td>
</tr>
<tr>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>read  (不可重复读)</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><table>
<thead>
<tr>
<th>r1</th>
<th>r2</th>
</tr>
</thead>
<tbody>
<tr>
<td>read (where id&gt;1)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert(id=2)</td>
</tr>
<tr>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>read (where id&gt;1)（幻读）</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="解决事务并发的方案：事务隔离"><a href="#解决事务并发的方案：事务隔离" class="headerlink" title="解决事务并发的方案：事务隔离"></a>解决事务并发的方案：事务隔离</h2><p>通过数据库引擎的事务隔离级别</p>
<p>serializable（串行化）</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>并发问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommited（未提交读)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>脏读</td>
</tr>
<tr>
<td>read commited（已提交读) 只读取已提交的数据，解决了脏读</td>
<td></td>
</tr>
<tr>
<td></td>
<td>不可重复读</td>
</tr>
<tr>
<td>repeatable read（可重复读） 在同一事务中多次读取同样的数据结果是一样的，解决不可重复读的问题，未解决幻读(innodb解决了幻读)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>read 幻读</td>
</tr>
<tr>
<td>serializable（串行化）</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="事务隔离级别的实现方案"><a href="#事务隔离级别的实现方案" class="headerlink" title="事务隔离级别的实现方案"></a>事务隔离级别的实现方案</h2><ol>
<li>LBCC(Lock Base concurrency control) 在读取数据之前，对其加锁，阻止其他事务对数据进行修改</li>
<li>MVCC(Multi Version concurrency control) 生成一个快照</li>
</ol>
<p>解决脏读：在r2事务(write/rollback)开始的时候，拿到排它锁，阻塞r1的读操作</p>
<p>解决不可重复读: 在r1开始的时候，拿到共享锁,阻塞r2的写操作</p>
<p>解决幻读：使用自增主键，行锁算法（范围）走临键锁</p>
<h2 id="事务隔离级别的实现细节–’读’操作"><a href="#事务隔离级别的实现细节–’读’操作" class="headerlink" title="事务隔离级别的实现细节–’读’操作"></a>事务隔离级别的实现细节–’读’操作</h2><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；</p>
<p>使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎</span><br><span class="line"></span><br><span class="line">会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</span><br><span class="line"></span><br><span class="line">一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，</span><br><span class="line"></span><br><span class="line">Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也</span><br><span class="line"></span><br><span class="line">会进行一个当前读。</span><br></pre></td></tr></table></figure>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</p>
<p>InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>
<h2 id="事务隔离级别的实现细节–’写’操作"><a href="#事务隔离级别的实现细节–’写’操作" class="headerlink" title="事务隔离级别的实现细节–’写’操作"></a>事务隔离级别的实现细节–’写’操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>myisam 只支持表锁<br>innodb 支持表锁和行锁</p>
<h2 id="innodb-锁类型"><a href="#innodb-锁类型" class="headerlink" title="innodb 锁类型"></a>innodb 锁类型</h2><ul>
<li>共享锁（行锁）</li>
<li>排它锁（行锁）</li>
<li>意向共享锁（表锁）</li>
<li>意向排它锁（表锁）</li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>多个事务获取同一条数据的共享锁。在共享锁期间，其他事务不能对数据进行写操作</p>
<h3 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h3><p>只能有一个事务对一条数据创建排它锁。其他事务不能读也不能写</p>
<p>在一个事务中，update，delete，insert会自动针对数据加一个排它锁</p>
<h2 id="锁的算法（范围）"><a href="#锁的算法（范围）" class="headerlink" title="锁的算法（范围）"></a>锁的算法（范围）</h2><ul>
<li>记录锁</li>
<li>间隙锁</li>
<li>临键锁</li>
</ul>
<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；</p>
<p>当等值查询，有命中行数，且有命中唯一索引（唯一索引，主键索引）的时候，使用 记录锁</p>
<p>当范围查询，未命中的时候，使用 间隙锁。 间隙锁只在rr事务隔离级别存在</p>
<p>当范围查询，且有命中行数的时候，使用 临键锁。或者理解为除了（间隙锁，记录锁以外，其他都是临键锁）</p>
<h2 id="主键索引和唯一索引"><a href="#主键索引和唯一索引" class="headerlink" title="主键索引和唯一索引"></a>主键索引和唯一索引</h2><p>主键索引和唯一索引。 主键索引是特殊的唯一索引。 主键索引不允许为null值，唯一索引允许存在一个null值</p>
<h2 id="关于是否阻塞的总结"><a href="#关于是否阻塞的总结" class="headerlink" title="关于是否阻塞的总结"></a>关于是否阻塞的总结</h2><p>定值查询</p>
<table>
<thead>
<tr>
<th>r1</th>
<th>r2</th>
<th>是否命中相同数据</th>
<th>r2是否阻塞</th>
</tr>
</thead>
<tbody>
<tr>
<td>走索引</td>
<td>没走索引</td>
<td></td>
<td>阻塞</td>
</tr>
<tr>
<td>走索引</td>
<td>走索引</td>
<td>是</td>
<td>阻塞</td>
</tr>
<tr>
<td>走索引</td>
<td>走索引</td>
<td>否</td>
<td>不阻塞</td>
</tr>
<tr>
<td>没走索引</td>
<td>走索引</td>
<td></td>
<td>阻塞</td>
</tr>
<tr>
<td>没走索引</td>
<td>没走索引</td>
<td></td>
<td>阻塞</td>
</tr>
</tbody>
</table>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="非唯一索引，等值查询命中后，会使用哪种锁算法（记录锁，间隙锁，临键锁）？"><a href="#非唯一索引，等值查询命中后，会使用哪种锁算法（记录锁，间隙锁，临键锁）？" class="headerlink" title="非唯一索引，等值查询命中后，会使用哪种锁算法（记录锁，间隙锁，临键锁）？"></a>非唯一索引，等值查询命中后，会使用哪种锁算法（记录锁，间隙锁，临键锁）？</h3><h3 id="如果行锁会造成表锁（意向锁），那么行锁的意义是什么？"><a href="#如果行锁会造成表锁（意向锁），那么行锁的意义是什么？" class="headerlink" title="如果行锁会造成表锁（意向锁），那么行锁的意义是什么？"></a>如果行锁会造成表锁（意向锁），那么行锁的意义是什么？</h3><h3 id="以不可重复读或者幻读为例，为什么同一事务不能出现两次读取不一致的问题？"><a href="#以不可重复读或者幻读为例，为什么同一事务不能出现两次读取不一致的问题？" class="headerlink" title="以不可重复读或者幻读为例，为什么同一事务不能出现两次读取不一致的问题？"></a>以不可重复读或者幻读为例，为什么同一事务不能出现两次读取不一致的问题？</h3><p>因为会破坏事务的一致性</p>
<h3 id="对上面概念的梳理"><a href="#对上面概念的梳理" class="headerlink" title="对上面概念的梳理"></a>对上面概念的梳理</h3><img src="/2019/02/20/mysql事务与锁/事务.png" title="右键新标签页打开,可看大图">
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://pan.baidu.com/s/1RTtrmm5RqtdztUpfhIoFeg?fid=1099705773141400" target="_blank" rel="noopener">mysql事务与锁 视频</a><br><a href="https://segmentfault.com/a/1190000014133576#articleHeader5" target="_blank" rel="noopener">mysql锁</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/docker-compose部署wordpress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/docker-compose部署wordpress/" itemprop="url">docker-compose部署wordpress</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T19:18:37+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="体验wordpress"><a href="#体验wordpress" class="headerlink" title="体验wordpress"></a>体验wordpress</h1><p>使用docker-compose安装wordpress</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>移除旧的版本：</p>
<pre><code>$ sudo yum remove docker \
    docker-client \
    docker-client-latest \
    docker-common \
    docker-latest \
    docker-latest-logrotate \
    docker-logrotate \
    docker-selinux \
    docker-engine-selinux \
    docker-engine
</code></pre><p>安装一些必要的系统工具：</p>
<pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre><p>添加软件源信息：</p>
<pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre><p>更新 yum 缓存：</p>
<pre><code>sudo yum makecache fast
</code></pre><p>安装 Docker-ce：</p>
<pre><code>sudo yum -y install docker-ce
</code></pre><p>启动 Docker 后台服务</p>
<pre><code>sudo systemctl start docker
</code></pre><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>需要先安装企业版linux附加包（epel)</p>
<pre><code>yum -y install epel-release
</code></pre><p>安装pip</p>
<pre><code>yum -y install python-pip
</code></pre><p>更新pip</p>
<pre><code>pip install --upgrade pip
</code></pre><p>安装docker-compose</p>
<pre><code>pip install docker-compose
</code></pre><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   db:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="attr">       - db_data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   wordpress:</span></span><br><span class="line"><span class="attr">     depends_on:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">wordpress:latest</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"8000:80"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db_data:</span></span><br></pre></td></tr></table></figure>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>中间出现过一次Access denied for user ‘wordpress‘@’172.18.0.3’的错误，原因是之前有一份yml文件，设置的 MYSQL_PASSWORD和本次不一样。</p>
<p>网上资料上的解决方案是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker-compose rm -v 删除之前容器的的volumes文件（一般是在/var/lib/docker/volumes）</span><br></pre></td></tr></table></figure>
<p>但是我使用 docker-compose rm -v，并没有删除文件</p>
<p>最后我索性直接把docker卸载重装了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/28/postgresql性能优化笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/postgresql性能优化笔记/" itemprop="url">postgresql性能优化笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-28T20:03:36+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="pg-stat-activity"><a href="#pg-stat-activity" class="headerlink" title="pg_stat_activity"></a>pg_stat_activity</h1><ol>
<li><p>pg_stat_activity.state 状态解析</p>
</li>
<li><p>update语句导致idle in transaction</p>
</li>
<li><p>query 字段为COMMIT</p>
</li>
<li><p>query 字段为BEGIN READ WRITE</p>
</li>
<li><p>query 为 SELECT 某些较长的sql展示为这个</p>
</li>
<li><p>client_addr 有些为192.168</p>
</li>
<li><p>realtime left join base VS base left join realtime</p>
</li>
</ol>
<h1 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h1><ol>
<li>start_up_cost all_cost</li>
</ol>
<h1 id="json字段优化"><a href="#json字段优化" class="headerlink" title="json字段优化"></a>json字段优化</h1><ol>
<li>使用json_extract_path_text(effects,’Consumption’))，使用的时候比较麻烦</li>
<li><p>修改为jsonb，使用gin索引<br> create index idx_resource_20180926_consum on resource_20180926 USING gin (effects);</p>
</li>
<li><p>直接使用json字段索引<br> CREATE INDEX ON resource_20180926((effects-&gt;&gt;’Consumption’));</p>
</li>
</ol>
<h1 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h1><ol>
<li><p>如何让left join走索引</p>
<p>  SELECT A</p>
<pre><code>.user_id
</code></pre><p> FROM</p>
<pre><code>base.unit
A LEFT JOIN base.resource b ON A.user_id = b.user_id 
AND A.auth_id = b.auth_id 
AND A.campaign_id = b.campaign_id 
AND A.unit_id = b.unit_id
LEFT JOIN base.target C ON A.user_id = C.user_id 
AND A.auth_id = C.auth_id 
AND A.campaign_id = C.campaign_id 
AND A.unit_id = C.unit_id
LEFT JOIN base.creative d ON A.user_id = d.user_id 
AND A.auth_id = d.auth_id 
AND A.campaign_id = d.campaign_id 
AND A.unit_id = d.unit_id 
</code></pre><p> WHERE</p>
<pre><code>( A.deleted_at IS NULL AND b.deleted_at IS NULL AND C.deleted_at IS NULL AND d.deleted_at IS NULL ) 

AND (
    A.platform = 2
AND A.user_id = &apos;998825031364526080&apos; 
AND A.auth_id = &apos;1044508644000931840&apos;)
</code></pre></li>
</ol>
<p>上面sql的golang代码</p>
<pre><code>units := []base.Unit{}
err := resource.DB.
    Select(&quot;a.user_id, a.auth_id, a.campaign_id, a.unit_id, b.meta_resource_id, a.unit_name, a.config_status, a.passive_status, a.work_time, a.start_time, a.end_time&quot;).
    Table(&quot;base.unit a&quot;).
    Joins(&quot;left join base.resource b on a.user_id = b.user_id and a.auth_id = b.auth_id and a.campaign_id = b.campaign_id and a.unit_id = b.unit_id&quot;).
    Joins(&quot;left join base.target c on a.user_id = c.user_id and a.auth_id = c.auth_id and a.campaign_id = c.campaign_id and a.unit_id = c.unit_id&quot;).
    Joins(&quot;left join base.creative d on a.user_id = d.user_id and a.auth_id = d.auth_id and a.campaign_id = d.campaign_id and a.unit_id = d.unit_id&quot;).
    Where(&quot;a.deleted_at is null and b.deleted_at is null and c.deleted_at is null and d.deleted_at is null&quot;).
    Where(&quot;a.platform = ? and a.user_id = ? and a.auth_id = ?&quot;, 2, &quot;998825031364526080&quot;, &quot;1044508644000931840&quot;).
    Limit(1).
    Scan(&amp;units).Error
fmt.Println(&quot;err:&quot;, err)
</code></pre><h1 id="cpu利用率飙高"><a href="#cpu利用率飙高" class="headerlink" title="cpu利用率飙高"></a>cpu利用率飙高</h1><p>消息堆积</p>
<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><h2 id="只有带user-id才能走索引"><a href="#只有带user-id才能走索引" class="headerlink" title="只有带user_id才能走索引"></a>只有带user_id才能走索引</h2><pre><code>EXPLAIN ANALYSE SELECT * FROM &quot;base&quot;.&quot;resource&quot; WHERE &quot;base&quot;.&quot;resource&quot;.&quot;deleted_at&quot; IS NULL AND (( auth_id = &apos;1044508644000931840&apos; ) 
AND ( resource_id = &apos;sc_213523592969230286&apos; ) 
AND ( user_id = &apos;998825031364526080&apos; ) 
);
</code></pre><h2 id="索引不仅仅需要命中"><a href="#索引不仅仅需要命中" class="headerlink" title="索引不仅仅需要命中"></a>索引不仅仅需要命中</h2><p>explain ANALYSE SELECT * FROM “base”.”resource” WHERE “base”.”resource”.”deleted_at” IS NULL AND ((user_id = ‘1046367009123614720’) AND (auth_id = ‘1046367009182326784’) AND (resource_id = ‘sc_-1866255835007264483’) AND (platform = ‘2’)<br>and campaign_id = ‘112455583’ and unit_id = ‘128115026’ )</p>
<p>VS</p>
<p>explain ANALYSE SELECT * FROM “base”.”resource” WHERE “base”.”resource”.”deleted_at” IS NULL AND ((user_id = ‘1046367009123614720’) AND (auth_id = ‘1046367009182326784’) AND (resource_id = ‘sc_-1866255835007264483’) AND (platform = ‘2’)<br>)</p>
<h1 id="写在join中还是where中？"><a href="#写在join中还是where中？" class="headerlink" title="写在join中还是where中？"></a>写在join中还是where中？</h1><h1 id="gin索引对json字段性能提升"><a href="#gin索引对json字段性能提升" class="headerlink" title="gin索引对json字段性能提升"></a>gin索引对json字段性能提升</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/snowflake-分布式唯一ID生成器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/snowflake-分布式唯一ID生成器/" itemprop="url">snowflake-分布式唯一ID生成器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T14:10:04+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要了解snowflake"><a href="#为什么要了解snowflake" class="headerlink" title="为什么要了解snowflake"></a>为什么要了解snowflake</h1><ol>
<li><p>数据库分表以后，数据库自增id无法满足全局唯一的性质</p>
</li>
<li><p>uuid作为主键无法保证id递增</p>
</li>
</ol>
<h1 id="snowflake算法原理"><a href="#snowflake算法原理" class="headerlink" title="snowflake算法原理"></a>snowflake算法原理</h1><img src="/2018/09/13/snowflake-分布式唯一ID生成器/snowflake.jpg" title="snowflake">
<p>首先我们需要的是一个int64的id，可以通过对这64位bit划分命名空间，分别用来表示 时间戳，机器等来实现id唯一性。</p>
<p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间</p>
<p>10-bit机器可以分别表示1024台机器（5个bit是数据中心，5个bit的机器ID），这种5-5的划分实际上是可以自定义的。</p>
<p>12个自增序列号表示同一时间戳，同一机器下的自增流水号.</p>
<p>上面的设计保证了理论上snowflake方案的QPS约为409.6w/s（2^12*1000）。</p>
<h1 id="snowflake实现"><a href="#snowflake实现" class="headerlink" title="snowflake实现"></a>snowflake实现</h1><p>直接参考github上的一个snowflake实现，代码略有删减</p>
<pre><code>var (
    // 起始时间戳 这个可以根据实际情况定义，如果项目是从2018-01-01运行，就可以设置为2018-01-01的时间戳，可以使用到2087年
    Epoch int64 = 1288834974657

    // 机器标识位
    NodeBits uint8 = 10

    // 自增序列号
    StepBits uint8 = 12

    // 机器标识最大值，实例化node时不能大于nodeMax
    nodeMax   int64 = -1 ^ (-1 &lt;&lt; NodeBits)

    // 用于step循环的一个标识
    stepMask  int64 = -1 ^ (-1 &lt;&lt; StepBits)

    // snowflake需要的一个参数
    timeShift uint8 = NodeBits + StepBits

    // 相当于自增序列号
    nodeShift uint8 = StepBits
)

// 生成id的节点服务
type Node struct {
    mu   sync.Mutex
    time int64 // 最近使用的时间戳
    node int64 // 机器标识
    step int64 // 自增序列
}

// 实例化一个节点服务
func NewNode(node int64) (*Node, error) {
    if node &lt; 0 || node &gt; nodeMax {
        return nil, errors.New(&quot;Node number must be between 0 and &quot; + strconv.FormatInt(nodeMax, 10))
    }

    return &amp;Node{
        time: 0,
        node: node,
        step: 0,
    }, nil
}

// 生成id
func (n *Node) Generate() ID {

    n.mu.Lock()

    now := time.Now().UnixNano() / 1000000

    if n.time == now {
        n.step = (n.step + 1) &amp; stepMask

        // 如果某一时间戳下的自增序列用完了，则切换时间戳
        if n.step == 0 {
            for now &lt;= n.time {
                now = time.Now().UnixNano() / 1000000
            }
        }
    } else {
        n.step = 0
    }

    n.time = now

    // snowflake算法
    r := ID((now-Epoch)&lt;&lt;timeShift |
        (n.node &lt;&lt; nodeShift) |
        (n.step),
    )

    n.mu.Unlock()
    return r
}
</code></pre><h1 id="如何保证多个snowflake节点生成的id不重复"><a href="#如何保证多个snowflake节点生成的id不重复" class="headerlink" title="如何保证多个snowflake节点生成的id不重复"></a>如何保证多个snowflake节点生成的id不重复</h1><p>试想一下，如果部署两个snowflake节点，初始化的时候node值都为1，那么在同一毫秒内两个请求分别打在了两个节点上，那么有可能将会获取两个同样的id（time,node,step全部相同）。所以问题的关键是保证部署的时候，初始化workId(node)值不能重复。</p>
<p>其中一种解决方案是，通过etcd存储node列表</p>
<ul>
<li>服务初始化时，连接etcd服务，获取指定key下的node列表 list</li>
<li>遍历list，取出一个最小的已过期的key值作为workId返回</li>
<li>定时刷新该key值的过期时间，如果服务挂掉，超过过期时间后该key值可能会被其他服务占用</li>
</ul>
<h1 id="唯一ID的其他解决方案"><a href="#唯一ID的其他解决方案" class="headerlink" title="唯一ID的其他解决方案"></a>唯一ID的其他解决方案</h1><ul>
<li>UUID</li>
<li>数据库自增长序列或字段</li>
<li>步长+数据库自增序列</li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="什么是趋势递增"><a href="#什么是趋势递增" class="headerlink" title="什么是趋势递增"></a>什么是趋势递增</h2><p>趋势递增指的是同一节点下产生的id是递增的。</p>
<p>在多个snowflake节点的情况下，因为节点的workId不同，同一时间下获取的id有可能是多个节点产生的，此时就无法保证全局递增</p>
<h2 id="如果etcd挂了怎么办？"><a href="#如果etcd挂了怎么办？" class="headerlink" title="如果etcd挂了怎么办？"></a>如果etcd挂了怎么办？</h2><p>可以在每次获取workId后，将workId存到本地。</p>
<h2 id="解决时钟回退问题"><a href="#解决时钟回退问题" class="headerlink" title="解决时钟回退问题"></a>解决时钟回退问题</h2><p>时间回流的原因一般是因为服务器做时间同步，此时可能出现生成重复id的情况。</p>
<p>首先判断node.time是否大于当前服务器时间，如果大于说明发生了时间回流，返回错误并报警</p>
<p>每隔一段时间(3s)上报自身系统时间写入</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a><br><a href="https://juejin.im/post/5a7f9176f265da4e721c73a8" target="_blank" rel="noopener">分布式唯一id：snowflake算法思考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/设计模式/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T22:54:42+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HeadFirst设计模式"><a href="#HeadFirst设计模式" class="headerlink" title="HeadFirst设计模式"></a>HeadFirst设计模式</h1><p>花了一周时间把这本书读完了，感觉受益良多。其中有几个模式让我感觉相见恨晚，之前有几个项目场景如果能结合设计模式来实现，应该能节省很多维护的工作。还有其他几种设计模式，并没有感觉到它们的威力。另外，各个设计模式之间的差异也让我有点绕不出来，这个只能靠以后慢慢理清了。</p>
<h1 id="模式是什么？"><a href="#模式是什么？" class="headerlink" title="模式是什么？"></a>模式是什么？</h1><p>书中提到: 模式是在某情景下，针对某问题的某种解决方案。</p>
<ul>
<li>情景（情景）</li>
<li>问题（需求）</li>
<li>解决方案（模式）</li>
</ul>
<p>举个例子：</p>
<p>情景-我要准时上班<br>问题-我将钥匙锁在车里了<br>解决方案1-打破窗户，进入车内，启动引擎，然后开车上班</p>
<h1 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h1><p>设计模式在模式的基础上，还包括了适用性，即最佳实践。</p>
<p>上述的例子，打破窗户虽然是一种解决方案，但是没有解决成本约束，可能不是一个很好的解决方案。</p>
<h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>设计模式虽然不是原则，更不是法律，但是它提供了一种指导方针。</p>
<p>我最近几个月一直在纠结一个问题，如何才能写出优秀甚至完美的代码？之前的很多项目代码，我觉得用另外一种结构也可以实现，但是我不知道哪种选择才是最正确的，甚至我一度认为之前的代码都是垃圾代码。</p>
<p>了解了设计模式之后，我找到了一些答案。目前我现在认为在当前情境下，满足以下三个条件，就是优秀的代码</p>
<ul>
<li>条理清晰</li>
<li>易于维护</li>
<li>方便扩展</li>
</ul>
<p>至于完美的代码，当然存在，但是只有极少情况下才会出现：需求不会再更改了。</p>
<p>从这个角度上来说，<code>fmt.Pritln(&quot;Hello World&quot;)&quot;</code>也算是一句”完美”代码了 -_-</p>
<h1 id="如何学习设计模式？"><a href="#如何学习设计模式？" class="headerlink" title="如何学习设计模式？"></a>如何学习设计模式？</h1><h2 id="“反设计模式”-vs-设计模式"><a href="#“反设计模式”-vs-设计模式" class="headerlink" title="“反设计模式” vs 设计模式"></a>“反设计模式” vs 设计模式</h2><p>没有对比就没有伤害，针对遇到的问题，思考一些”反设计模式”,然后与设计模式做对比</p>
<h2 id="设计模式-vs-设计模式"><a href="#设计模式-vs-设计模式" class="headerlink" title="设计模式 vs 设计模式"></a>设计模式 vs 设计模式</h2><p>同一个问题，既能抽象工厂模式能解决，也能使用模版方法解决。横向对比设计模式之间的差异</p>
<h2 id="发掘开源项目中的设计模式"><a href="#发掘开源项目中的设计模式" class="headerlink" title="发掘开源项目中的设计模式"></a>发掘开源项目中的设计模式</h2><p>我在读这本书的时候，读到观察者模式会想到nsq，读到模版方法会想到beego controller的设计，读到工厂方法会想到jaeger中初始化存储组件的代码，读到go-redis客户端代码会想到命令模式。</p>
<p>优秀的开源项目肯定包含了大量的设计模式，以后阅读的时候可以好好品味。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>毕业两年半，来到新公司已经半年了，博客也停更半年了。接下来的2018希望能更认真的对待博客～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/12/golang的OpenTracing和jeager使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/golang的OpenTracing和jeager使用/" itemprop="url">golang的OpenTracing和jaeger使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T16:23:13+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="OpenTracing是什么？"><a href="#OpenTracing是什么？" class="headerlink" title="OpenTracing是什么？"></a>OpenTracing是什么？</h2><p>当代分布式跟踪系统（例如，Zipkin, Dapper, HTrace, X-Trace等）旨在解决这些问题，但是他们使用不兼容的API来实现各自的应用需求。尽管这些分布式追踪系统有着相似的API语法，但各种语言的开发人员依然很难将他们各自的系统（使用不同的语言和技术）和特定的分布式追踪系统进行整合.</p>
<p>OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 OpenTracing提供了用于运营支撑系统的和针对特定平台的辅助程序库。</p>
<p>已经实现OpenTracing协议的项目有：</p>
<ul>
<li>Zipkin</li>
<li>Jaeger</li>
<li>Appdash</li>
</ul>
<h2 id="jaeger和OpenTracing"><a href="#jaeger和OpenTracing" class="headerlink" title="jaeger和OpenTracing"></a>jaeger和OpenTracing</h2><p>jaeger实现了OpenTracing，而且后端存储支持memry(默认)，elasticsearch,cassandra</p>
<h2 id="jaeger使用"><a href="#jaeger使用" class="headerlink" title="jaeger使用"></a>jaeger使用</h2><p>创建一个支持serve模式和client模式的web服务</p>
<pre><code>// main.go
package main
import (
    &quot;flag&quot;
    &quot;log&quot;

    jaegerClientConfig &quot;github.com/uber/jaeger-client-go/config&quot;
)

var (
    serverPort = flag.String(&quot;port&quot;, &quot;8000&quot;, &quot;server port&quot;)
    // 默认为服务模式
    actorKind  = flag.String(&quot;actor&quot;, &quot;server&quot;, &quot;server or client&quot;)
)

const (
    server = &quot;server&quot;
    client = &quot;client&quot;
)

func main() {
    flag.Parse()

    if *actorKind != server &amp;&amp; *actorKind != client {
        log.Fatal(&quot;Please specify &apos;-actor server&apos; or &apos;-actor client&apos;&quot;)
    }

    cfg := jaegerClientConfig.Configuration{
        Sampler: &amp;jaegerClientConfig.SamplerConfig{
            Type:  &quot;const&quot;,
            Param: 1.0, // sample all traces
        },
    }
    // jaeger.NewRemoteReporter(transport)
    tracer, closer, _ := cfg.New(*actorKind)
    defer closer.Close()

    if *actorKind == server {
        runServer(tracer)
        return
    }

    runClient(tracer)

    // Close the tracer to guarantee that all spans that could
    // be still buffered in memory are sent to the tracing backend
    closer.Close()
}
</code></pre><p>服务器模式</p>
<pre><code>// server.go
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;

    &quot;github.com/opentracing-contrib/go-stdlib/nethttp&quot;
    &quot;github.com/opentracing/opentracing-go&quot;
)

func getTime(w http.ResponseWriter, r *http.Request) {
    log.Print(&quot;Received getTime request&quot;)
    t := time.Now()
    ts := t.Format(&quot;Mon Jan _2 15:04:05 2006&quot;)
    io.WriteString(w, fmt.Sprintf(&quot;The time is %s&quot;, ts))
}

func redirect(w http.ResponseWriter, r *http.Request) {
    http.Redirect(w, r,
        fmt.Sprintf(&quot;http://localhost:%s/gettime&quot;, *serverPort), 301)
}

func runServer(tracer opentracing.Tracer) {
    http.HandleFunc(&quot;/gettime&quot;, getTime)
    http.HandleFunc(&quot;/&quot;, redirect)
    log.Printf(&quot;Starting server on port %s&quot;, *serverPort)
    err := http.ListenAndServe(
        fmt.Sprintf(&quot;:%s&quot;, *serverPort),
        // use nethttp.Middleware to enable OpenTracing for server
        nethttp.Middleware(tracer, http.DefaultServeMux))
    if err != nil {
        log.Fatalf(&quot;Cannot start server: %s&quot;, err)
    }
}
</code></pre><p>客户端模式</p>
<pre><code>// client.go
package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/opentracing-contrib/go-stdlib/nethttp&quot;
    &quot;github.com/opentracing/opentracing-go&quot;
    &quot;github.com/opentracing/opentracing-go/ext&quot;
    otlog &quot;github.com/opentracing/opentracing-go/log&quot;
    &quot;golang.org/x/net/context&quot;
)

func runClient(tracer opentracing.Tracer) {
    // nethttp.Transport from go-stdlib will do the tracing
    c := &amp;http.Client{Transport: &amp;nethttp.Transport{}}

    // create a top-level span to represent full work of the client
    span := tracer.StartSpan(client)
    span.SetTag(string(ext.Component), client)
    defer span.Finish()
    ctx := opentracing.ContextWithSpan(context.Background(), span)

    req, err := http.NewRequest(
        &quot;GET&quot;,
        fmt.Sprintf(&quot;http://localhost:%s/&quot;, *serverPort),
        nil,
    )
    if err != nil {
        onError(span, err)
        return
    }

    req = req.WithContext(ctx)
    // wrap the request in nethttp.TraceRequest
    req, ht := nethttp.TraceRequest(tracer, req)
    defer ht.Finish()

    res, err := c.Do(req)
    if err != nil {
        onError(span, err)
        return
    }
    defer res.Body.Close()
    body, err := ioutil.ReadAll(res.Body)
    if err != nil {
        onError(span, err)
        return
    }
    fmt.Printf(&quot;Received result: %s\n&quot;, string(body))
}

func onError(span opentracing.Span, err error) {
    // handle errors by recording them in the span
    span.SetTag(string(ext.Error), true)
    span.LogKV(otlog.Error(err))
    log.Print(err)
}
</code></pre><p>编译<br>go build</p>
<p>执行客户端请求代码<br>    ./opentracing-go-nethttp-demo</p>
<p>运行jaeger的docker镜像<br>    docker run -d -p5775:5775/udp -p16686:16686 jaegertracing/all-in-one:latest</p>
<p>执行客户端代码<br>    ./opentracing-go-nethttp-demo -actor client</p>
<p>此时访问 <a href="http://localhost:16686就可以看到jaeger上的记录了。" target="_blank" rel="noopener">http://localhost:16686就可以看到jaeger上的记录了。</a></p>
<img src="/2018/06/12/golang的OpenTracing和jeager使用/jaeger1.png">
<p>但是记录好像少了点，只有jaeger-query的，client和server的信息都没记录，查了下资料发现是因为启动jaeger的时候有些端口没开放。</p>
<pre><code>docker run \
-p 5775:5775/udp \
-p 16686:16686 \
-p 6831:6831/udp \
-p 6832:6832/udp \
-p 5778:5778 \
-p 14268:14268 \
jaegertracing/all-in-one:latest
</code></pre><h2 id="封装http请求"><a href="#封装http请求" class="headerlink" title="封装http请求"></a>封装http请求</h2><p>上面的例子就是对http请求的trace</p>
<h2 id="将数据存储在es中"><a href="#将数据存储在es中" class="headerlink" title="将数据存储在es中"></a>将数据存储在es中</h2><p>暂时还没成功，后面会更新。这里先把目前的操作记录下来。</p>
<p>在本地用docker启动了elasticsearch</p>
<pre><code>docker run -d -p 9200:9200 -e &quot;http.host=0.0.0.0&quot; -e &quot;transport.host=127.0.0.1&quot; docker.elastic.co/elasticsearch/elasticsearch:5.4.0
</code></pre><p>在本地用docker-compose启动jaeger</p>
<p>doker-compose.yaml:</p>
<pre><code>jaegertracing:
image: jaegertracing/all-in-one:latest
ports:
    - &quot;5775:5775/udp&quot;
    - &quot;6831:6831/udp&quot;
    - &quot;6832:6832/udp&quot;
    - &quot;5778:5778&quot;
    - &quot;16686:16686&quot;
    - &quot;14268:14268&quot;
command:
    - &quot;/go/bin/standalone-linux&quot;
    - &quot;--span-storage.type=elasticsearch&quot;
    - &quot;--query.static-files=/go/src/jaeger-ui-build/build/&quot;
environment:
  - SPAN_STORAGE_TYPE=elasticsearch
</code></pre><p>报错：<br>    {“level”:”fatal”,”ts”:1528814826.4817529,”caller”:”standalone/main.go:106”,”msg”:”Failed to init storage factory”,”error”:”health check timeout: no Elasticsearch node available”,”errorVerbose”:”no Elasticsearch node available…</p>
<p>解决：</p>
<h3 id="启动es的方式改为："><a href="#启动es的方式改为：" class="headerlink" title="启动es的方式改为："></a>启动es的方式改为：</h3><pre><code>docker run -it --rm -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;xpack.security.enabled=false&quot; docker.elastic.co/elasticsearch/elasticsearch:5.4.0
</code></pre><h3 id="启动jaeger前将宿主主机ip写入到环境变量："><a href="#启动jaeger前将宿主主机ip写入到环境变量：" class="headerlink" title="启动jaeger前将宿主主机ip写入到环境变量："></a>启动jaeger前将宿主主机ip写入到环境变量：</h3><pre><code>export DOCKERHOST=$(ifconfig | grep -E &quot;([0-9]{1,3}\.){3}[0-9]{1,3}&quot; | grep -v 127.0.0.1 | awk &apos;{ print $2 }&apos; | cut -f2 -d: | head -n1)
</code></pre><h3 id="修改docker-compose文件"><a href="#修改docker-compose文件" class="headerlink" title="修改docker-compose文件"></a>修改docker-compose文件</h3><pre><code>jaegertracing:
image: jaegertracing/all-in-one:latest
ports:
    - &quot;5775:5775/udp&quot;
    - &quot;6831:6831/udp&quot;
    - &quot;6832:6832/udp&quot;
    - &quot;5778:5778&quot;
    - &quot;16686:16686&quot;
    - &quot;14268:14268&quot;
command:
    - &quot;/go/bin/standalone-linux&quot;
    - &quot;--span-storage.type=elasticsearch&quot;
    - &quot;--query.static-files=/go/src/jaeger-ui-build/build/&quot;
environment:
    - SPAN_STORAGE_TYPE=elasticsearch
    - ES_SERVER_URLS=http://$DOCKERHOST:9200
</code></pre><h3 id="启动jaeger"><a href="#启动jaeger" class="headerlink" title="启动jaeger"></a>启动jaeger</h3><pre><code>docker-compose -f jaeger-start-docker.yaml up
</code></pre><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><img src="/2018/06/12/golang的OpenTracing和jeager使用/jaeger-es.png" title="启动成功">
<h3 id="补充几个es的查询语句"><a href="#补充几个es的查询语句" class="headerlink" title="补充几个es的查询语句"></a>补充几个es的查询语句</h3><ul>
<li><p>检查es状态<br>  curl <a href="http://127.0.0.1:9200" target="_blank" rel="noopener">http://127.0.0.1:9200</a></p>
</li>
<li><p>检查节点状态<br>  curl <a href="http://127.0.0.1:9200/_cat/health" target="_blank" rel="noopener">http://127.0.0.1:9200/_cat/health</a></p>
</li>
<li><p>查询某天的数据<br>  curl <a href="http://localhost:9200/jaeger-span-2018-06-14/_search" target="_blank" rel="noopener">http://localhost:9200/jaeger-span-2018-06-14/_search</a></p>
</li>
<li><p>查询数据数量<br>  curl <a href="http://localhost:9200/jaeger-span-\*/_count" target="_blank" rel="noopener">http://localhost:9200/jaeger-span-\*/_count</a></p>
</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/jaegertracing/jaeger-performance/blob/master/standalone/README.md" target="_blank" rel="noopener">jaeger test文档</a></p>
<p><a href="https://medium.com/opentracing/tracing-http-request-latency-in-go-with-opentracing-7cc1282a100a" target="_blank" rel="noopener">httptrace和opentracing</a></p>
<p><a href="https://www.jaegertracing.io/docs/getting-started/" target="_blank" rel="noopener">jaeger官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/golang的time-Time遇到的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/golang的time-Time遇到的坑/" itemprop="url">golang的time.Time遇到的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T23:20:53+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="坑的起源"><a href="#坑的起源" class="headerlink" title="坑的起源"></a>坑的起源</h2><p>使用不同的时区操作</p>
<h2 id="后端存储的时间戳数字"><a href="#后端存储的时间戳数字" class="headerlink" title="后端存储的时间戳数字"></a>后端存储的时间戳数字</h2><pre><code>// 入库操作
now := time.Now().Unix()
fmt.Println(now) // 2018-6-11 06:00:00 +0800 CST
db.Save(now)

// 查询操作
// 前端从时间框控件筛选时间(2018-6-11)，然后传至后端
startTime = 1528675200000
fmt.Println(startTime) // 2018-06-11 08:00:00 +0800 CST
// 错误出现 上面入库的数据因为是在6点(CST时区)入库，所以查询不到
</code></pre><h2 id="后端存储的是datetime类型"><a href="#后端存储的是datetime类型" class="headerlink" title="后端存储的是datetime类型"></a>后端存储的是datetime类型</h2><pre><code>t,_ := time.Parse(&quot;2006-01-02 15:04:05&quot;,&quot;2018-06-11 06:00:00&quot;) // UTC时区
db.Save(t)
</code></pre><h2 id="docker容器时区"><a href="#docker容器时区" class="headerlink" title="docker容器时区"></a>docker容器时区</h2><p>docker容器修改</p>
<h2 id="time-UnixNano-大于int64的最大值"><a href="#time-UnixNano-大于int64的最大值" class="headerlink" title="time.UnixNano() 大于int64的最大值"></a>time.UnixNano() 大于int64的最大值</h2><p>这个问题，标准包中已经说明了</p>
<pre><code>// UnixNano returns t as a Unix time, the number of nanoseconds elapsed
// since January 1, 1970 UTC. The result is undefined if the Unix time
// in nanoseconds cannot be represented by an int64 (a date before the year
// 1678 or after 2262). Note that this means the result of calling UnixNano
// on the zero Time is undefined.
func (t Time) UnixNano() int64 {
    return (t.unixSec())*1e9 + int64(t.nsec())
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>团队统一使用一个时区</li>
<li>不用time.Parse()，使用time.ParseInLocation()</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/优雅关闭的几种实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/优雅关闭的几种实现/" itemprop="url">优雅关闭的几种实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T09:43:07+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>等待进程处理完任务，关闭进程</p>
<h3 id="go1-8之后标准包实现优雅关闭"><a href="#go1-8之后标准包实现优雅关闭" class="headerlink" title="go1.8之后标准包实现优雅关闭"></a>go1.8之后标准包实现优雅关闭</h3><pre><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(5 * time.Second)
        fmt.Fprintf(w, &quot;Hello World, %v\n&quot;, time.Now())
        fmt.Println(&quot;hello:&quot;, time.Now())
    })

    s := &amp;http.Server{
        Addr:           &quot;:8080&quot;,
        Handler:        http.DefaultServeMux,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }

    go func() {
        log.Println(s.ListenAndServe())
        log.Println(&quot;server shutdown&quot;)
    }()

    // Handle SIGINT and SIGTERM.
    ch := make(chan os.Signal)
    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
    log.Println(&quot;ch:&quot;, &lt;-ch)

    // Stop the service gracefully.
    ctx := context.Background()
    log.Println(&quot;shut:&quot;, s.Shutdown(ctx))

    log.Println(&quot;done.&quot;)
}
</code></pre><h3 id="通过waitgroup实现"><a href="#通过waitgroup实现" class="headerlink" title="通过waitgroup实现"></a>通过waitgroup实现</h3><pre><code>参考beego.graceful.shutdown
</code></pre><h2 id="优雅重启"><a href="#优雅重启" class="headerlink" title="优雅重启"></a>优雅重启</h2><p>优雅关闭可以防止程序强制终止，导致的脏数据问题。但是在关闭到重启的期间，有一个真空期，用户的请求是不会被接收到的。优雅重启可以解决这类问题</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>fork子进程</li>
<li>父进程优雅关闭</li>
</ol>
<h3 id="通过共享listener，即socket文件，fork子进程"><a href="#通过共享listener，即socket文件，fork子进程" class="headerlink" title="通过共享listener，即socket文件，fork子进程"></a>通过共享listener，即socket文件，fork子进程</h3><pre><code>func forkAndRun(ln net.Listener) {
    l := ln.(*net.TCPListener)
    newFile, _ := l.File()

    cmd := exec.Command(os.Args[0], &quot;-graceful&quot;)
    cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr
    cmd.ExtraFiles = []*os.File{newFile}
    fmt.Printf(&quot;cmd:%#v&quot;, cmd)
    cmd.Run()
}
</code></pre><h3 id="fork子进程的时候，获取ppid，关闭父进程"><a href="#fork子进程的时候，获取ppid，关闭父进程" class="headerlink" title="fork子进程的时候，获取ppid，关闭父进程"></a>fork子进程的时候，获取ppid，关闭父进程</h3><pre><code>if graceful {
    process, err := os.FindProcess(os.Getppid())
    fmt.Println(&quot;ppid:&quot;, os.Getppid())
    if err != nil {
        log.Println(err)
        return err
    }
    err = process.Signal(syscall.SIGTERM)
    if err != nil {
        return err
    }
}
</code></pre><h3 id="160行代码实现一个graceful-server"><a href="#160行代码实现一个graceful-server" class="headerlink" title="160行代码实现一个graceful server"></a>160行代码实现一个graceful server</h3><pre><code>package mygrace

import (
    &quot;context&quot;
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

var (
    graceful bool
)

func init() {
    // 第一次启动时不要添加graceful，否则会报错
    flag.BoolVar(&amp;graceful, &quot;graceful&quot;, false, &quot;is graceful&quot;)
}

type Server struct {
    ln net.Listener
    *http.Server
    Done chan bool
}

func NewServer(addr string, handler http.Handler) (srv *Server) {
    if !flag.Parsed() {
        flag.Parse()
    }
    srv = &amp;Server{Done: make(chan bool)}
    hsrv := &amp;http.Server{
        Addr:           addr,
        Handler:        handler,
        ReadTimeout:    10 * time.Second, // 值如果过小，会导致client端读取resp失败
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }
    srv.Server = hsrv
    return
}

// 这里addr可以不用传，因为下面
func ListenAndServe(addr string, handler http.Handler) error {
    s := NewServer(addr, handler)
    err := s.ListenAndServe()
    return err
}

func (srv *Server) ListenAndServe() error {
    // 这里获取listener
    // 如果是第一次启动，是从net.Listen获取
    // 其余情况，是根据文件描述符获取
    ln, err := srv.getListener()
    if err != nil {
        log.Println(&quot;srv.getListener():&quot;, err)
        return err
    }
    srv.ln = ln

    if graceful {
        process, err := os.FindProcess(os.Getppid())
        log.Println(&quot;ppid:&quot;, os.Getppid())
        if err != nil {
            log.Println(err)
            return err
        }
        err = process.Signal(syscall.SIGTERM)
        if err != nil {
            return err
        }
    }
    log.Println(os.Getpid(), srv.Addr)
    go srv.Serve(srv.ln)
    go srv.handleSignals()
    &lt;-srv.Done
    log.Println(&quot;srv done!!!&quot;)
    return nil
}

func (srv *Server) shutdown() error {
    ctx := context.Background()
    err := srv.Shutdown(ctx)
    srv.Done &lt;- true
    return err
}

func (srv *Server) fork() error {

    tl := srv.ln.(*net.TCPListener)
    file, err := tl.File()
    if err != nil {
        log.Println(&quot;ln.File() err:&quot;, err)
        return err
    }

    cmd := exec.Command(os.Args[0], &quot;-graceful&quot;)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Stdin = os.Stdin
    cmd.ExtraFiles = []*os.File{file}
    err = cmd.Start()
    if err != nil {
        log.Fatalf(&quot;Restart: Failed to launch, error: %v&quot;, err)
    }
    return nil
}

func (srv *Server) handleSignals() {
    for {
        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)

        sigMsg := &lt;-sig
        switch sigMsg {
        case syscall.SIGHUP:
            log.Println(&quot;receive syscall.SIGHUP&quot;)
            err := srv.fork()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
        case syscall.SIGINT:
            log.Println(&quot;receive syscall.SIGINT&quot;)
            err := srv.shutdown()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
            return
        case syscall.SIGTERM:
            log.Println(&quot;receive syscall.SIGTERM&quot;)
            err := srv.shutdown()
            if err != nil {
                log.Println(&quot;srv.fork() err:&quot;, err)
            }
            return
        }
    }
    return
}

func (srv *Server) getListener() (l net.Listener, err error) {
    if graceful {
        f := os.NewFile(uintptr(3), &quot;&quot;)
        l, err = net.FileListener(f)
        if err != nil {
            err = fmt.Errorf(&quot;net.FileListener error: %v&quot;, err)
            return
        }
    } else {
        l, err = net.Listen(&quot;tcp&quot;, srv.Addr)
        if err != nil {
            err = fmt.Errorf(&quot;net.Listen error: %v&quot;, err)
            return
        }
    }
    return
}
</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>在分布式的环境下，有必要优雅重启吗？<br>虽然分布式环境可以避免用户请求的真空期，但是还是会可能产生脏数据。</p>
</li>
<li><p>有时候出现服务端执行完成，但是客户端读取response失败？<br>也许可以尝试：在服务端初始化http.Server的时候，可以把ReadTimeout，WriteTimeout时间调长一点</p>
</li>
<li><p>beego的grace正确使用姿势？<br>在配置文件中，Graceful设置为true，重启时使用kill -1 xxx来结束程序。另外第一次执行程序时不要加参数 -graceful=true，否则getListener会因为查找listener失败的，并且因为这个时候程序的ppid为1，是没有权限杀死的，beego这一块没有做错误处理。</p>
</li>
<li><p>os.FindProcess(os.Getppid()) 查出来的ppid等于1？<br>有两种可能，1.直接调用了-graceful参数；2.find的时候父进程已经结束，该进程会转移为1下面的子进程</p>
</li>
<li><p>getListener方法中，为什么根据 os.NewFile(uintptr(3), “”) 就能获取之前的socket文件？<br>有待研究</p>
</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://jiajunhuang.com/articles/2017_10_25-golang_graceful_restart.md.html" target="_blank" rel="noopener">Golang实现平滑重启(优雅重启)</a></p>
<p><a href="https://github.com/astaxie/beego/tree/master/grace" target="_blank" rel="noopener">beego的graceful实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/golang实现ECC加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/golang实现ECC加密/" itemprop="url">golang实现ECC加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T10:46:39+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上.</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。</p>
<p>椭圆曲线依赖的数学难题是:</p>
<pre><code>k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知q和P，很难计算出k
</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>golang 标准包中直接提供了密钥生成的方法</p>
<pre><code>// 初始化椭圆曲线
pubkeyCurve := elliptic.P256()
// 随机挑选基点,生成私钥
p, err := ecdsa.GenerateKey(pubkeyCurve, rand.Reader)
if err != nil {
    fmt.Println(&quot;1&quot;, err)
    os.Exit(1)
}
PRIVATE = p
</code></pre><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>golang标准包中没有提供加密和解密算法,但是以太坊go-ethereum实现了相关算法,这里对其进行二次封装</p>
<pre><code>// 将标准包生成私钥转化为ecies私钥
prv2 = ecies.ImportECDSA(PRIVATE)
// ecc(ecies)加密
func ECCEncrypt(pt []byte) ([]byte, error) {
    ct, err := ecies.Encrypt(rand.Reader, &amp;prv2.PublicKey, pt, nil, nil)
    return ct, err
}
// ecc(ecies)解密
func ECCDecrypt(ct []byte) ([]byte, error) {
    pt, err := prv2.Decrypt(ct, nil, nil)
    return pt, err
}
</code></pre><h2 id="签名和验签"><a href="#签名和验签" class="headerlink" title="签名和验签"></a>签名和验签</h2><p>golang标准包中提供了相关方法</p>
<pre><code>func EccSign(pt []byte) (sign []byte, err error) {
    // 根据明文plaintext和私钥，生成两个big.Ing
    r, s, err := ecdsa.Sign(rand.Reader, PRIVATE, pt)
    if err != nil {
        fmt.Println(err)
        return nil, err
    }
    rs, err := r.MarshalText()
    if err != nil {
        return nil, err
    }
    ss, err := s.MarshalText()
    if err != nil {
        return nil, err
    }
    // 将r，s合并（以“+”分割），作为签名返回
    var b bytes.Buffer
    b.Write(rs)
    b.Write([]byte(`+`))
    b.Write(ss)
    return b.Bytes(), nil
}

func EccSignVer(pt, sign []byte) bool {
    var rint, sint big.Int
    // 根据sign，解析出r，s
    rs := bytes.Split(sign, []byte(&quot;+&quot;))
    rint.UnmarshalText(rs[0])
    sint.UnmarshalText(rs[1])
    // 根据公钥，明文，r，s验证签名
    v := ecdsa.Verify(&amp;PRIVATE.PublicKey, pt, &amp;rint, &amp;sint)
    return v
}
</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="ECC-ECIES-ECDSA-ECDH-是什么关系-有哪些区别"><a href="#ECC-ECIES-ECDSA-ECDH-是什么关系-有哪些区别" class="headerlink" title="ECC,ECIES,ECDSA,ECDH 是什么关系,有哪些区别?"></a>ECC,ECIES,ECDSA,ECDH 是什么关系,有哪些区别?</h3><ul>
<li>ECC,全称椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC）,主要是指相关数学原理</li>
<li>ECIES,在ECC原理的基础上实现的一种公钥加密方法,和RSA类似</li>
<li>ECDSA,在ECC原理上实现的签名方法</li>
<li>ECDH在ECC和DH的基础上实现的密钥交换算法</li>
</ul>
<h3 id="RSA算法的密钥对可以通过-pem文件来保存-ECC的密钥对要如何保存呢"><a href="#RSA算法的密钥对可以通过-pem文件来保存-ECC的密钥对要如何保存呢" class="headerlink" title="RSA算法的密钥对可以通过.pem文件来保存,ECC的密钥对要如何保存呢?"></a>RSA算法的密钥对可以通过.pem文件来保存,ECC的密钥对要如何保存呢?</h3><p>go-ethereum提供了两种对外接口.</p>
<p>密钥对和[]byte之间的转换</p>
<pre><code>// 私钥 -&gt; []byte
// FromECDSA exports a private key into a binary dump.
func FromECDSA(priv *ecdsa.PrivateKey) []byte {
    if priv == nil {
        return nil
    }
    return math.PaddedBigBytes(priv.D, priv.Params().BitSize/8)
}

// []byte -&gt; 私钥
// ToECDSA creates a private key with the given D value.
func ToECDSA(d []byte) (*ecdsa.PrivateKey, error) {
    return toECDSA(d, true)
}

// 公钥 -&gt; []byte
func FromECDSAPub(pub *ecdsa.PublicKey) []byte {
    if pub == nil || pub.X == nil || pub.Y == nil {
        return nil
    }
    return elliptic.Marshal(S256(), pub.X, pub.Y)
}

// []byte -&gt; 公钥
    func ToECDSAPub(pub []byte) *ecdsa.PublicKey {
    if len(pub) == 0 {
        return nil
    }
    x, y := elliptic.Unmarshal(S256(), pub)
    return &amp;ecdsa.PublicKey{Curve: S256(), X: x, Y: y}
}
</code></pre><p><strong>公钥转换的时候需要注意,eth中默认使用的椭圆曲线是S256().生成密钥对时,如果使用的是其他椭圆曲线(如P256),需要对FromECDSAPub,ToECDSAPub稍作修改</strong></p>
<p>密钥对和文件之间的转换,其实就是在中间加一层hex编码</p>
<pre><code>// 私钥 -&gt; 文件
// SaveECDSA saves a secp256k1 private key to the given file with
// restrictive permissions. The key data is saved hex-encoded.
func SaveECDSA(file string, key *ecdsa.PrivateKey) error {
    k := hex.EncodeToString(FromECDSA(key))
    return ioutil.WriteFile(file, []byte(k), 0600)
}

// 文件 -&gt; 私钥
func LoadECDSA(file string) (*ecdsa.PrivateKey, error) {
    buf := make([]byte, 64)
    fd, err := os.Open(file)
    if err != nil {
        return nil, err
    }
    defer fd.Close()
    if _, err := io.ReadFull(fd, buf); err != nil {
        return nil, err
    }

    key, err := hex.DecodeString(string(buf))
    if err != nil {
        return nil, err
    }
    return ToECDSA(key)
}
</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://zhuanlan.zhihu.com/p/35225057" target="_blank" rel="noopener">椭圆曲线数学原理 (上篇)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35587405" target="_blank" rel="noopener">椭圆曲线数学原理 (下篇)</a></p>
<p><a href="https://crypto.stackexchange.com/questions/12823/ecdsa-vs-ecies-vs-ecdh" target="_blank" rel="noopener">ECIES,ECDSA,ECDH三者的区别</a></p>
<p><a href="https://github.com/ethereum/go-ethereum/tree/master/crypto/ecies" target="_blank" rel="noopener">以太坊ecies实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/05/golang实现RSA加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/golang实现RSA加密/" itemprop="url">golang实现RSA加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T09:38:14+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1976年之前，所有加密方式都是同一种模式：甲乙双方使用同一种加密算法和密钥，即对称加密。这种模式有一个弱点：甲方必须先把加密规则和密钥告诉乙方。这样导致保存和传递密钥，成为了一个头疼的问题。</p>
<p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman密钥交换算法”。这个算法启发了其他科学家。人们认识到，<strong>加密和解密可以使用不同的密钥</strong>，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p>这种新的加密模式被称为”非对称加密算法”。</p>
<p>RSA是非对称加密中的一种。</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>大整数的因数分解，是一件非常困难的事情。例如你可以对3233进行因数分解（61×53），但对较大整数进行因数分解就比较困难了。</p>
<p>这里提供一个golang实现的暴力因数分解，有兴趣可以跑一下试试：</p>
<pre><code>// 因数分解
// 因为大整数s可能会超过uint64的最大值，所以这里用字符串来作为输入参数
func factorization(s string) (x, y *big.Int, err error) {
    df := big.NewInt(1)
    x = big.NewInt(2)
    n, flag := big.NewInt(1).SetString(s, 0)
    if !flag {
        return nil, nil, errors.New(&quot;invalid string&quot;)
    }
    for ; x.Cmp(n) == -1; x.Add(x, big.NewInt(1)) {
        fmt.Println(&quot;x:&quot;, x.String())
        if df.Mod(n, x).String() == &quot;0&quot; {
            return x, df.Div(n, x), nil
        }
    }
    return nil, nil, errors.New(&quot;end faild&quot;)
}
</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>A想与B进行加密通信，首先要生成一个密钥：</p>
<ol>
<li><p>A选择两个大质数，得到乘积n，再随机选择一个整数e，计算e对于φ(n)的模反元素d。</p>
</li>
<li><p>将（n，e）作为公钥，（n，d）作为私钥</p>
</li>
</ol>
<p>可以证明，如果想通过公钥获取私钥，难度取决于大整数因数分解的效率。</p>
<p>关于模反元素和相关推导，可以看<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">链接</a>，比想象中简单</p>
<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p>B想给A发送信息m</p>
<ol>
<li><p>将m转化为整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
</li>
<li><p>根据公式<br> m^e ≡ c (mod n)<br>已知m（明文），e（公钥的一部分），n（公钥的一部分），可以得到密文c</p>
</li>
</ol>
<h3 id="私钥解密"><a href="#私钥解密" class="headerlink" title="私钥解密"></a>私钥解密</h3><ol>
<li><p>得到密文c</p>
</li>
<li><p>根据公式<br> c^d ≡ m (mod n)<br>已知 c（密文），d（私钥的一部分），n（私钥的一部分），可以得到明文m</p>
</li>
</ol>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">证明根据根据以上公式获取的明文和原始明文一致</a></p>
<h2 id="golang代码实现RSA密钥生成"><a href="#golang代码实现RSA密钥生成" class="headerlink" title="golang代码实现RSA密钥生成"></a>golang代码实现RSA密钥生成</h2><pre><code>//生成公钥和私钥 pem文件

package encryp

import (
    &quot;crypto/rand&quot;
    &quot;crypto/rsa&quot;
    &quot;crypto/x509&quot;
    &quot;encoding/pem&quot;
    &quot;os&quot;
)

//生成 私钥和公钥文件
func GenRsaKey(bits int) error {
    //生成私钥文件
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return err
    }
    derStream := x509.MarshalPKCS1PrivateKey(privateKey)
    block := &amp;pem.Block{
        Type:  &quot;RSA PRIVATE KEY&quot;,
        Bytes: derStream,
    }
    file, err := os.Create(&quot;private.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(file, block)
    if err != nil {
        return err
    }
    //生成公钥文件
    publicKey := &amp;privateKey.PublicKey
    defPkix, err := x509.MarshalPKIXPublicKey(publicKey)
    if err != nil {
        return err
    }
    block = &amp;pem.Block{
        Type:  &quot;RSA PUBLIC KEY&quot;,
        Bytes: defPkix,
    }
    file, err = os.Create(&quot;public.pem&quot;)
    if err != nil {
        return err
    }
    err = pem.Encode(file, block)
    if err != nil {
        return err
    }
    return nil
}
</code></pre><h2 id="golang实现RSA加密和解密"><a href="#golang实现RSA加密和解密" class="headerlink" title="golang实现RSA加密和解密"></a>golang实现RSA加密和解密</h2><pre><code>// 读取公钥私钥
var privateKey, publicKey []byte
func init() {
    var err error
    publicKey, err = ioutil.ReadFile(&quot;public.pem&quot;)
    if err != nil {
        os.Exit(-1)
    }
    privateKey, err = ioutil.ReadFile(&quot;private.pem&quot;)
    if err != nil {
        os.Exit(-1)
    }
}

// 公钥加密
func RsaEncrypt(data []byte) ([]byte, error) {
    //解密pem格式的公钥
    block, _ := pem.Decode(publicKey)
    if block == nil {
        return nil, errors.New(&quot;public key error&quot;)
    }
    // 解析公钥
    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 类型断言
    pub := pubInterface.(*rsa.PublicKey)
    //加密
    return rsa.EncryptPKCS1v15(rand.Reader, pub, data)
}

// 私钥解密
func RsaDecrypt(ciphertext []byte) ([]byte, error) {
    //获取私钥
    block, _ := pem.Decode(privateKey)
    if block == nil {
        return nil, errors.New(&quot;private key error!&quot;)
    }
    //解析PKCS1格式的私钥
    priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    // 解密
    return rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)
}
</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理-欧拉函数</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/git.png"
                alt="Yh Zhang" />
            
              <p class="site-author-name" itemprop="name">Yh Zhang</p>
              <p class="site-description motion-element" itemprop="description">See you again</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yh Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
