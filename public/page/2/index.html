<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="See you again">
<meta property="og:type" content="website">
<meta property="og:title" content="Z">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Z">
<meta property="og:description" content="See you again">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Z">
<meta name="twitter:description" content="See you again">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Z</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Z</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/golang实现DES加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/golang实现DES加密/" itemprop="url">golang实现DES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T11:35:28+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DES简介"><a href="#DES简介" class="headerlink" title="DES简介"></a>DES简介</h2><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。</p>
<h3 id="概念隐喻"><a href="#概念隐喻" class="headerlink" title="概念隐喻"></a>概念隐喻</h3><ul>
<li>加密 - 做蛋糕</li>
<li>明文 - 原材料</li>
<li>IV初始向量 - 厨师. IV长度必须与block.Size保持一致. 维基百科上说重复使用IV会导致安全隐患</li>
<li>block - 一套工具</li>
<li>工作模式 - 工具使用说明书,有EBC,CBC等</li>
<li>Padding填充模式 - 检查原材料.块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的.因此部分模式（即ECB和CBC）需要最后一块在加密前进行填充</li>
</ul>
<h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程:"></a>加密过程:</h3><ul>
<li>block = 密钥切割</li>
<li>pdata = padding + data</li>
<li>加密算法 = 工作模式+初始向量+block 代码:cipher.NewCBCEncrypter(block,iv)</li>
<li>密文 = 加密算法 + pdata </li>
</ul>
<h3 id="解密过程-解密算法其实是对密文的加密"><a href="#解密过程-解密算法其实是对密文的加密" class="headerlink" title="解密过程(解密算法其实是对密文的加密)"></a>解密过程(解密算法其实是对密文的加密)</h3><ul>
<li>block = 密钥切割</li>
<li>解密算法 = 工作模式+初始向量+block 代码:cipher.NewCBCDecrypter(block,iv)</li>
<li>明文padding = 解密算法 + 密文</li>
<li>明文 = unpadding + 明文padding</li>
</ul>
<p>EBC(Electronic codebook)和CBC(Cipher-block Chain)的比较:</p>
<ul>
<li>EBC 同样的明文块会被加密成相同的密文块.</li>
<li>CBC 每个明文块先与前一个密文块进行异或后，再进行加密.</li>
<li>安全强度上CBC更强</li>
<li>CBC无法并行加密</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>// DES加密
func DesEncrypt(origData, key []byte) ([]byte, error) {
    // 根据密钥生成block
    block, err := des.NewCipher(key)
    if err != nil {
        return nil, err
    }
    // 根据block和初始向量生成加密算法,IV长度与block.size需要保持一致
    blockMode := cipher.NewCBCEncrypter(block, IV)
    // 扩充 origData
    origData = PKCS5Padding(origData, block.BlockSize())
    crypted := make([]byte, len(origData))
    // 对padded data加密
    blockMode.CryptBlocks(crypted, origData)
    return crypted, nil
}

// DES解密
func DesDecrypt(crypted, key []byte) ([]byte, error) {
    // 根据密钥生成block
    block, err := des.NewCipher(key)
    if err != nil {
        return nil, err
    }
    // 根据block和初始向量生成解密算法,IV长度与block.size需要保持一致
    blockMode := cipher.NewCBCDecrypter(block, IV)
    // 对密文解密
    origData := make([]byte, len(crypted))
    blockMode.CryptBlocks(origData, crypted)
    // 反扩充,获取原始明文
    origData = PKCS5UnPadding(origData)
    return origData, nil
}
</code></pre><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接:"></a>相关链接:</h3><p><a href="https://www.jianshu.com/p/c44a8a1b7c38" target="_blank" rel="noopener">DES加密算法原理</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工作模式 ECB,CBC</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/关于加密算法的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/关于加密算法的理解/" itemprop="url">关于加密算法的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T21:43:24+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul>
<li>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。</li>
<li>3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li>
<li>AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</li>
</ul>
<p>总结(相同数据,相同密钥):</p>
<ol>
<li>DES速度是3DES的三倍</li>
<li>AES分为根据密钥长度分为AES-128,AES-192,AES-256,三者性能差别不大</li>
<li>AES性能优于DES</li>
</ol>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul>
<li>RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；</li>
<li>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）；</li>
<li>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码学。</li>
</ul>
<p>总结: </p>
<ol>
<li>RSA随着密钥对的长度增长,加解密速度会明显降低</li>
<li>目前还没实现</li>
<li><p>目前还没实现,但是根据ECC签名以及网上的资料表示,ECC会逐渐成为主流</p>
<p> 对称加密,非对称加密的前提条件都是要先生成密钥或者密钥对</p>
</li>
</ol>
<h2 id="哈系算法"><a href="#哈系算法" class="headerlink" title="哈系算法"></a>哈系算法</h2><ul>
<li>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法。</li>
<li>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值；</li>
</ul>
<p>总结: </p>
<ol>
<li>SHA比MD5复杂强度更高,但是运行速度较慢.</li>
<li>哈系算法一般会结合非对称加密,实现签名-验签</li>
</ol>
<h2 id="签名-验签"><a href="#签名-验签" class="headerlink" title="签名-验签"></a>签名-验签</h2><ul>
<li>RSA+hash(sha,mad5)</li>
<li>ECC</li>
</ul>
<h2 id="加密-解密-和-签名-验签的区别"><a href="#加密-解密-和-签名-验签的区别" class="headerlink" title="加密/解密 和 签名/验签的区别"></a>加密/解密 和 签名/验签的区别</h2><ol>
<li>一般都使用非对称加密</li>
<li>前者使用公钥加密,私钥解密</li>
<li>后者使用私钥签名,公钥验签</li>
<li>签名/验签的过程不一定需要反向解密</li>
</ol>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><p><a href="https://zhuanlan.zhihu.com/p/35225057" target="_blank" rel="noopener">椭圆曲线加密教程 (上篇)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35587405" target="_blank" rel="noopener">椭圆曲线加密教程 (下篇)</a></p>
<p><a href="https://blog.csdn.net/qq_21794823/article/details/53114819" target="_blank" rel="noopener">常见加密算法分类,用途,原理以及比较</a></p>
<p>目前只是研究了ECC算法原理,但是理解上还差一点,后期补上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/代码大全-阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/代码大全-阅读笔记/" itemprop="url">代码大全-阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T09:46:27+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做过很多需求.每次需求过来,稍微分析一下就开始建表写代码.两年下来,总感觉对开发流程,代码规范的认知缺少深度,这里想通过阅读<strong>代码大全</strong>这本经典,对自己做一次总结.</p>
<h2 id="什么是软件构建"><a href="#什么是软件构建" class="headerlink" title="什么是软件构建"></a>什么是软件构建</h2><h3 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h3><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="规划构建"><a href="#规划构建" class="headerlink" title="规划构建"></a>规划构建</h3><h3 id="高层设计"><a href="#高层设计" class="headerlink" title="高层设计"></a>高层设计</h3><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><h3 id="编码与调试"><a href="#编码与调试" class="headerlink" title="编码与调试"></a>编码与调试</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><h3 id="保障维护"><a href="#保障维护" class="headerlink" title="保障维护"></a>保障维护</h3><hr>
<h2 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h2><p>写作,代价是丢掉一张草稿</p>
<p>培育,软件开发相当于系统生长,骨架-肌肉-皮肤,增量式开发.</p>
<p>建造, 定义问题-设计(线路)-审查(质检)</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>有些人断言,前期准备毫无用处.</p>
<p>前期准备不周全的原因:</p>
<ol>
<li>不具备相关规划技能.学习</li>
<li>尽快编码的欲望.总结之前的项目痛点</li>
</ol>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>问题定义只定义了问题是什么,而不涉及任何可能的解决方案</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>为什么会有变更?</p>
<p>随着客户参与项目的时间增长,他们对项目的理解也就越深.</p>
<p>平均情况,25%的需求会有变化.特殊情况,75%-85%的需求变更</p>
<h2 id="架构的组成部分"><a href="#架构的组成部分" class="headerlink" title="架构的组成部分"></a>架构的组成部分</h2><h3 id="程序组织-Programma-Organization"><a href="#程序组织-Programma-Organization" class="headerlink" title="程序组织 Programma Organization"></a>程序组织 Programma Organization</h3><h3 id="主要的类-Major-Classes"><a href="#主要的类-Major-Classes" class="headerlink" title="主要的类 Major Classes"></a>主要的类 Major Classes</h3><p>80/20法则:对哪些构成系统80%的行为的20%的类进行详细说明</p>
<h3 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h3><p>数据通常只应该由一个子系统或者一个类直接访问</p>
<h3 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h3><h3 id="用户界面设计"><a href="#用户界面设计" class="headerlink" title="用户界面设计"></a>用户界面设计</h3><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><h3 id="互用性"><a href="#互用性" class="headerlink" title="互用性"></a>互用性</h3><h3 id="国际化-本地化"><a href="#国际化-本地化" class="headerlink" title="国际化/本地化"></a>国际化/本地化</h3><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>%90的代码用来处理异常情况,10%的代码处理常规情况</p>
<p>一般被认为是代码约定层次的事情</p>
<p>以下是关于错误处理需要考虑的事情:</p>
<ul>
<li>进行纠正还是检测?</li>
<li>检测是主动还是被动?</li>
<li>如果传播错误?</li>
<li>错误消息的处理有什么约定?</li>
<li>如何处理异常?记录或者描述</li>
<li>每个类在验证输入数据的有效性方面,需要负何种责任?每个类都验证,还是有一个类负责验证整个系统的数据有效性?</li>
<li>使用运行环境的错误处理机制,还是自己建立一套?</li>
</ul>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>容错策略:</p>
<ul>
<li>检测到错误退回去,退回到之前一切正常的时刻,从该点继续运行</li>
<li>切换到另外一套辅助程序</li>
<li>表决算法</li>
<li>使用默认值代替错误值</li>
<li>遇到错误时,进入”部分运转”的状态</li>
</ul>
<h3 id="架构的可行性"><a href="#架构的可行性" class="headerlink" title="架构的可行性"></a>架构的可行性</h3><h3 id="过度工程"><a href="#过度工程" class="headerlink" title="过度工程"></a>过度工程</h3><h3 id="买还是造"><a href="#买还是造" class="headerlink" title="买还是造"></a>买还是造</h3><h3 id="关于复用的决策"><a href="#关于复用的决策" class="headerlink" title="关于复用的决策"></a>关于复用的决策</h3><h3 id="变更策略"><a href="#变更策略" class="headerlink" title="变更策略"></a>变更策略</h3><p>表驱动技术</p>
<h3 id="架构的总体质量"><a href="#架构的总体质量" class="headerlink" title="架构的总体质量"></a>架构的总体质量</h3><p>你,作为一个实现该系统的程序员,是否对这个架构感觉良好?</p>
<h2 id="构建中的设计"><a href="#构建中的设计" class="headerlink" title="构建中的设计"></a>构建中的设计</h2><p>设计是一个险恶(wicked)的问题,wicked指的是你必须把这个问题”解决”一遍,才能明确地定义它,然后再次解决该问题,从而形成一个可行的方案.</p>
<h2 id="关键的设计概念"><a href="#关键的设计概念" class="headerlink" title="关键的设计概念"></a>关键的设计概念</h2><h3 id="设计的难题主要包括偶然的难题和本质的难题"><a href="#设计的难题主要包括偶然的难题和本质的难题" class="headerlink" title="设计的难题主要包括偶然的难题和本质的难题"></a>设计的难题主要包括偶然的难题和本质的难题</h3><h3 id="管理复杂度"><a href="#管理复杂度" class="headerlink" title="管理复杂度"></a>管理复杂度</h3><h4 id="复杂度原因"><a href="#复杂度原因" class="headerlink" title="复杂度原因"></a>复杂度原因</h4><ul>
<li>用复杂的方法解决简单的问题</li>
<li>用简单但错误的方法解决复杂的问题</li>
<li>用正确但复杂的问题解决复杂的问题</li>
</ul>
<h4 id="应对复杂度"><a href="#应对复杂度" class="headerlink" title="应对复杂度"></a>应对复杂度</h4><ul>
<li>最小复杂度 避免做出”聪明的设计”,应该做出简单且易于理解的设计</li>
<li>易于维护 为其他程序员着想</li>
<li>松散耦合 设计出关联尽可能少的类</li>
<li>可扩展性</li>
<li>可重用性</li>
<li>高扇入(被利用) 让大量的类使用某个子类</li>
<li>低扇出 少量或适中地使用其他的类(7个以下)</li>
<li>精简性 一本书的完成,不在他不能再加入任何内容的时候,而在不能再删去任何内容的时候</li>
<li>层次性</li>
<li>标准技术</li>
</ul>
<h3 id="设计的层次"><a href="#设计的层次" class="headerlink" title="设计的层次"></a>设计的层次</h3><ul>
<li>子系统或者包 子系统之间的调用,应该是无环图</li>
<li>分解为类</li>
<li>分解为子程序</li>
<li>子程序内部的设计</li>
</ul>
<h3 id="找出容易改变的区域"><a href="#找出容易改变的区域" class="headerlink" title="找出容易改变的区域"></a>找出容易改变的区域</h3><h4 id="对变化的预期能力"><a href="#对变化的预期能力" class="headerlink" title="对变化的预期能力"></a>对变化的预期能力</h4><ul>
<li>找出看起来容易变化的项目</li>
<li>把容易变化的项目分离出来</li>
<li>把看起来容易变化的项目隔离开来</li>
</ul>
<h4 id="容易变化的区域"><a href="#容易变化的区域" class="headerlink" title="容易变化的区域"></a>容易变化的区域</h4><ul>
<li>业务规则</li>
<li>对硬件的依赖性</li>
<li>输入和输出</li>
<li>非标准的语言特性</li>
<li>困难的设计区域和构建区域</li>
<li>状态变量</li>
<li>常量</li>
</ul>
<h3 id="耦合标准"><a href="#耦合标准" class="headerlink" title="耦合标准"></a>耦合标准</h3><p>尽可能缩减相互连接</p>
<h3 id="耦合的种类"><a href="#耦合的种类" class="headerlink" title="耦合的种类"></a>耦合的种类</h3><h4 id="简单数据参数耦合"><a href="#简单数据参数耦合" class="headerlink" title="简单数据参数耦合"></a>简单数据参数耦合</h4><h4 id="简单对象耦合"><a href="#简单对象耦合" class="headerlink" title="简单对象耦合"></a>简单对象耦合</h4><h4 id="对象参数耦合"><a href="#对象参数耦合" class="headerlink" title="对象参数耦合"></a>对象参数耦合</h4><h4 id="语义上的耦合-使用潜在的耦合假设-危险"><a href="#语义上的耦合-使用潜在的耦合假设-危险" class="headerlink" title="语义上的耦合,使用潜在的耦合假设,危险"></a>语义上的耦合,使用潜在的耦合假设,危险</h4><p>类和子程序适用于降低复杂度的首选和最重要的智力工具,如果他们没帮助你简化工作,那么他们就是失职的</p>
<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><p>设计模式是一种非常强大的管理复杂度的工具</p>
<p>但同时也存在一个潜在的陷阱:”为了模式而模式”,有时候对代码进行一些微小的改动,以符合某个广为人知的模式,会使这段代码更容易理解.</p>
<p>但是如果一段代码做出巨大改动,迫使它去符合某个标准模式,有时反而会把问题复杂化</p>
<h3 id="数学领域的解题思路"><a href="#数学领域的解题思路" class="headerlink" title="数学领域的解题思路"></a>数学领域的解题思路</h3><ul>
<li>理解问题,未知量,现有数据,条件分别是什么.现有数据是否足够,或者不够</li>
<li>再次之前你遇到过这个问题吗,或者类似的问题.</li>
<li>盯住未知量,试着想出一个有着相同或者类似未知量的问题来</li>
<li>现在能重述这个问题吗,用之前不同的方式重述</li>
<li>如果还是解决不了,试着先去解决一些相关的问题,一个更一般,或者更特殊,或者问题的一部分</li>
<li>设计一个计划,找出现有数据和未知量的联系</li>
<li>执行这一计划,能否检查每一步,并证明他是正确的</li>
<li>回顾整个解</li>
</ul>
<h2 id="前期要做多少设计才够"><a href="#前期要做多少设计才够" class="headerlink" title="前期要做多少设计才够"></a>前期要做多少设计才够</h2><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/interview/" itemprop="url">Knowledge-Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T17:11:27+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>增</li>
<li>删</li>
<li>改</li>
<li>查</li>
<li>翻转</li>
<li>合并</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>优先队列,最小/大栈</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>二叉树</li>
<li>红黑树</li>
</ul>
<h3 id="扩展结构"><a href="#扩展结构" class="headerlink" title="扩展结构"></a>扩展结构</h3><ul>
<li>trie</li>
<li>LRU(Least Recently Used)</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><ul>
<li>map实现</li>
<li>slice实现</li>
<li>channel实现</li>
<li>内存分配</li>
<li>调度</li>
<li>gc原理</li>
<li>性能优化</li>
<li>编译过程</li>
<li>版本变迁内容</li>
<li>channel常用模式</li>
<li>net高性能的原因</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>I/O模型</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><ul>
<li>http协议</li>
<li>浏览网页的过程分析 </li>
</ul>
<h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><h4 id="mysql-redis-mongo-nsq-etcd"><a href="#mysql-redis-mongo-nsq-etcd" class="headerlink" title="mysql,redis,mongo,nsq,etcd"></a>mysql,redis,mongo,nsq,etcd</h4><ul>
<li>应用场景</li>
<li>源码实现</li>
<li>表结构设计(mysql)</li>
<li>性能特色</li>
<li>高可用方案</li>
<li>监控</li>
<li>容灾</li>
<li>一致性实现</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前想问题时,总是把事情假设的太理想,明明知道可能会出问题,却有侥幸心理,不去深入研究.</p>
<p>笔试方面,需要多训练,提高思维速度.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/31/golang-sync-Map实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/golang-sync-Map实现原理/" itemprop="url">golang-sync.Map实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T17:41:59+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><pre><code>type Map struct {
    // 常用的锁,在操作dirty时会用到
    mu Mutex

    read atomic.Value // readOnly

    // dirty值要么为空,要么为全部键值对
    dirty map[interface{}]*entry

    // 在查询read时,命中失败的次数,当misses大于dirty长度时,read.m 会直接指向dirty
    misses int
}
</code></pre><p>Map.read实际值是readOnly结构体,可以看成是比dirty多了一个amended字段的结构</p>
<p>注意这个并不是真正的只读,添加操作是通过直接将m字段指向整个dirty完成的,删除操作是通过修改entry为expunged完成的</p>
<h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><pre><code>type readOnly struct {
    m       map[interface{}]*entry
    amended bool 
}
</code></pre><p> 主要看下readOnly.amended的值变化情况</p>
<ul>
<li><p>在Store方法中,添加新的键值对时,如果<strong>amended==false</strong>,会遍历read值,将其中未被标记为删除的记录,复制到dirty中,然后read.amended会被修改为true</p>
</li>
<li><p>在Load方法中,如果miss次数大于diry长度时,会将read.m直接指向dirty,且read.amended被置为false</p>
</li>
<li><p>如果<strong>amended==true</strong>,说明当前map时间节点处于新添加键值对之后,复制dirty到read之前,此时dirty不为空,且dirty包括所有Map中未被删除的数据,read中的数据可能少于dirty</p>
</li>
<li><p>如果<strong>amended==false</strong>,说明说明dirty为空</p>
</li>
</ul>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><pre><code>type entry struct {
    p unsafe.Pointer // *interface{}
}
</code></pre><p>实际是键值对中的value</p>
<h2 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h2><h3 id="寻值"><a href="#寻值" class="headerlink" title="寻值"></a>寻值</h3><pre><code>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            m.missLocked() // 如果read中没有,查询dirty
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}
</code></pre><h3 id="复制dirty到read-并清空dirty"><a href="#复制dirty到read-并清空dirty" class="headerlink" title="复制dirty到read,并清空dirty"></a>复制dirty到read,并清空dirty</h3><pre><code>func (m *Map) missLocked() {
    m.misses++
    if m.misses &lt; len(m.dirty) {
        return
    }
    m.read.Store(readOnly{m: m.dirty})
    m.dirty = nil
    m.misses = 0
}
</code></pre><h3 id="存值"><a href="#存值" class="headerlink" title="存值"></a>存值</h3><pre><code>func (m *Map) Store(key, value interface{}) {
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }

    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        if e.unexpungeLocked() {
            m.dirty[key] = e
        }
        e.storeLocked(&amp;value)
    } else if e, ok := m.dirty[key]; ok {
        e.storeLocked(&amp;value)
    } else {
        if !read.amended {
            m.dirtyLocked()
            m.read.Store(readOnly{m: read.m, amended: true})
        }
        m.dirty[key] = newEntry(value)
    }
    m.mu.Unlock()
}
</code></pre><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><h3 id="map-Store-a-”a”-gt-map-Store-b-”b”"><a href="#map-Store-a-”a”-gt-map-Store-b-”b”" class="headerlink" title="map.Store(a,”a”) -&gt; map.Store(b,”b”)"></a>map.Store(a,”a”) -&gt; map.Store(b,”b”)</h3><p>第一次map.Store(“a”,”a”)</p>
<ol>
<li>因为备份标记为false,执行m.dirtyLocked()</li>
<li>复制read -&gt; dirty</li>
<li>将备份标记read.amended更新为true</li>
<li>将a存在dirty中</li>
</ol>
<p>第二次map.Store(“b”,”b”)</p>
<ol>
<li>跳过if !read.amended 判断</li>
<li>向dirty中存储数据</li>
</ol>
<h3 id="map-Store-“a”-”a”-gt-map-Load-“a”-map-Store-“b”-”b”"><a href="#map-Store-“a”-”a”-gt-map-Load-“a”-map-Store-“b”-”b”" class="headerlink" title="map.Store(“a”,”a”) -&gt;map.Load(“a”) map.Store(“b”,”b”)"></a>map.Store(“a”,”a”) -&gt;map.Load(“a”) map.Store(“b”,”b”)</h3><p>map.Store(“a”,”a”)</p>
<ol>
<li>因为备份标记为false,执行m.dirtyLocked()</li>
<li>复制read -&gt; dirty</li>
<li>将read.amended更新为true</li>
<li>将a存在dirty中</li>
</ol>
<p>map.Load(“a”)</p>
<ol>
<li>从read中读取失败</li>
<li>从dirty中读取</li>
<li>m.missLocked()</li>
<li>miss+1</li>
<li>因为miss &gt;= len(dirty),直接将m.dirty复制到m.read中</li>
<li>备份标记m.read.amended = false</li>
<li>清空dirty</li>
</ol>
<p>map.Store(“b”,”b”)</p>
<ol>
<li>因为备份标记为false,执行m.dirtyLocked()</li>
<li>复制read -&gt; dirty</li>
<li>将read.amended更新为true</li>
<li>将a存在dirty中</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="sync-Map是如何保证性能比直接在map中加锁的性能好"><a href="#sync-Map是如何保证性能比直接在map中加锁的性能好" class="headerlink" title="sync.Map是如何保证性能比直接在map中加锁的性能好"></a>sync.Map是如何保证性能比直接在map中加锁的性能好</h3><p>当写入操作较多时,性能是无法保证的,因为每次都有可能要遍历read复制到dirty中</p>
<p>当读多写少时,read是atomic.Value类型, 读取时利用了atomic.Value.Load实现了原子操作,没有用到锁,所以性能有所提升</p>
<h3 id="怎么理解read-amended"><a href="#怎么理解read-amended" class="headerlink" title="怎么理解read.amended"></a>怎么理解read.amended</h3><p>可以把amended理解为一个备份标记,从read中遍历数据,复制到dirty中,相当于完成备份,amended为true,dirty为nil时,说明未备份,amended为false</p>
<h3 id="Map-read-和-Map-dirty的关系"><a href="#Map-read-和-Map-dirty的关系" class="headerlink" title="Map.read 和 Map.dirty的关系"></a>Map.read 和 Map.dirty的关系</h3><p>可以把read看成是缓存,当缓存命中失败次数过多时,会从dirty中复制数据到read中,如果dirty不为空,那么dirty的数据大于等于read</p>
<h3 id="从dirty中复制数据到read中-是否会导致原来的read中的数据丢失"><a href="#从dirty中复制数据到read中-是否会导致原来的read中的数据丢失" class="headerlink" title="从dirty中复制数据到read中,是否会导致原来的read中的数据丢失"></a>从dirty中复制数据到read中,是否会导致原来的read中的数据丢失</h3><p>不会,每次dirty创建时,都是从read中读取未被标记删除的数据复制到dirty中,之后dirty中的数据只会多于read,所以在从dirty中复制数据到read中时,只是会丢失已被标记删除的数据,而不会丢失实际数据</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://blog.yiz96.com/golang-sync-map/" target="_blank" rel="noopener">golang sync.Map 原理</a></p>
<p><a href="http://colobu.com/2017/07/11/dive-into-sync-Map/" target="_blank" rel="noopener">Go 1.9 sync.Map揭秘</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/30/golang-pprof实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/30/golang-pprof实践/" itemprop="url">golang-pprof实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T15:51:51+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在 golang官方博客的一篇<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">文章</a>中看到了详细使用go tool pprof优化程序的过程.<br>于是我把<a href="https://code.google.com/archive/p/benchgraffiti/source/default/source" target="_blank" rel="noopener">代码</a>clone下来,在本地实践了一次.</p>
<pre><code>➜  ~ go env
GOARCH=&quot;amd64&quot;
GOBIN=&quot;&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;linux&quot;
GOOS=&quot;linux&quot;
GOPATH=&quot;/home/skt/mygo&quot;
GORACE=&quot;&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;
GCCGO=&quot;gccgo&quot;
CC=&quot;gcc&quot;
GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build112976360=/tmp/go-build -gno-record-gcc-switches&quot;
CXX=&quot;g++&quot;
CGO_ENABLED=&quot;1&quot;
CGO_CFLAGS=&quot;-g -O2&quot;
CGO_CPPFLAGS=&quot;&quot;
CGO_CXXFLAGS=&quot;-g -O2&quot;
CGO_FFLAGS=&quot;-g -O2&quot;
CGO_LDFLAGS=&quot;-g -O2&quot;
PKG_CONFIG=&quot;pkg-config&quot;
</code></pre><h2 id="havlak背景"><a href="#havlak背景" class="headerlink" title="havlak背景"></a>havlak背景</h2><p>项目havlak,在C++版本的运行时间是17.8s,花费了700M的内存, Go版本花费了25.20s,使用了1302M内存,接下来会使用go tool pprof工具,对Go程序进行优化</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="havlak1"><a href="#havlak1" class="headerlink" title="havlak1"></a>havlak1</h3><p>切换到项目目录</p>
<pre><code>➜  ~ cd mygo/src/benchgraffiti/havlak 
➜  havlak 
</code></pre><p>这里我直接用go build ,而不是博客中的make</p>
<p>因为我执行make havlak1.prof的时候报错,说我没有6g工具</p>
<p>原来是MakeFile中使用6g工具编译的,也许是生成博客的时间(2011.6.24)太久远了吧</p>
<pre><code>➜  havlak go build havlak1.go
</code></pre><p>程序中给了-cpuprofile的接口,可以用来生成prof文件</p>
<pre><code>➜  havlak ./havlak1 -cpuprofile=havlak1.prof
# of loops: 76000 (including 1 artificial root node)
</code></pre><p>执行go tool pprof 二进制文件名 prof文件名,开始分析</p>
<pre><code>➜  havlak go tool pprof havlak1 havlak1.prof
File: havlak1
Type: cpu
Time: Mar 30, 2018 at 5:49pm (CST)
Duration: 21.48s, Total samples = 26.63s (123.97%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top10
Showing nodes accounting for 17790ms, 66.80% of 26630ms total
Dropped 121 nodes (cum &lt;= 133.15ms)
Showing top 10 nodes out of 66
  flat  flat%   sum%        cum   cum%
3500ms 13.14% 13.14%     6760ms 25.38%  runtime.scanobject /usr/local/go/src/runtime/mgcmark.go
3120ms 11.72% 24.86%     3330ms 12.50%  runtime.mapaccess1_fast64 /usr/local/go/src/runtime/hashmap_fast.go
2800ms 10.51% 35.37%    15770ms 59.22%  main.FindLoops /home/skt/mygo/src/benchgraffiti/havlak/havlak1.go
1720ms  6.46% 41.83%     1720ms  6.46%  runtime.heapBitsForObject /usr/local/go/src/runtime/mbitmap.go
1500ms  5.63% 47.47%     3600ms 13.52%  main.DFS /home/skt/mygo/src/benchgraffiti/havlak/havlak1.go
1440ms  5.41% 52.87%     4670ms 17.54%  runtime.mapassign_fast64 /usr/local/go/src/runtime/hashmap_fast.go
1170ms  4.39% 57.27%     5120ms 19.23%  runtime.mallocgc /usr/local/go/src/runtime/malloc.go
1010ms  3.79% 61.06%     1020ms  3.83%  runtime.greyobject /usr/local/go/src/runtime/mgcmark.go
 780ms  2.93% 63.99%     1270ms  4.77%  runtime.evacuate /usr/local/go/src/runtime/hashmap.go
 750ms  2.82% 66.80%      750ms  2.82%  runtime.memclrNoHeapPointers /usr/local/go/src/runtime/memclr_amd64.s
</code></pre><p>这里对各个列名解释一下:</p>
<ul>
<li>flat 表示采样时,命中到该函数的时长,去除该函数中对其它函数的调用所花费的时间,也有些文档把这一列理解为函数被调用次数</li>
<li>cum 表示采样时,命中到该函数的全部时长,包括函数中的其他调用所花费的时间</li>
<li>cum &gt;= flat,当cum远大于flat时,说明函数中有某个调用特别费时(比如上面的FindLoops,2800ms:15770ms)</li>
</ul>
<p>上面展示的内容和官博中的文章比较,有些出入,初步估计是因为go版本不一样,编译方式不一样导致的.先忽略这个问题.</p>
<p>分析上面的top10结果可以看到top1是runtime包的scanobject,mapaccess1_fast64,前者是gc相关的标记函数,后者是map寻值的操作.但是这个貌似不能直接看到我的程序哪里出问题了.怎么办呢?按照博客文章的顺序,我们先来分析后者.</p>
<p>我想知道我的程序哪里调用了runtime.mapaccess1_fast64</p>
<pre><code>(pprof) web runtime.mapaccess1_fast64
</code></pre><img src="/2018/03/30/golang-pprof实践/havlak1_mapaccess1_fast64.svg" title="右键新标签页打开,可看大图">
<p>可以看到主要有两个地方调用了mapaccess1_fast64,<strong>DFS</strong>和<strong>FindLoops</strong></p>
<p>接着我想知道具体DFS或者FindLoops的哪一行导致问题的</p>
<pre><code>(pprof) list DFS
Total: 26.63s
ROUTINE ======================== main.DFS in /home/skt/mygo/src/benchgraffiti/havlak/havlak1.go
 1.50s      7.16s (flat, cum) 26.89% of Total
         .          .    240:func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int {
  10ms       10ms    241:    nodes[current].Init(currentNode, current)
  10ms      160ms    242:    number[currentNode] = current
     .          .    243:
     .          .    244:    lastid := current
 1.10s      1.10s    245:    for _, target := range currentNode.OutEdges {
 150ms      1.63s    246:        if number[target] == unvisited {
  40ms      3.60s    247:            lastid = DFS(target, nodes, number, last, lastid+1)
     .          .    248:        }
     .          .    249:    }
 120ms      590ms    250:    last[number[currentNode]] = lastid
  30ms       30ms    251:    return lastid
     .          .    252:}
     .          .    253:
     .          .    254:// FindLoops
     .          .    255://
     .          .    256:// Find loops and build loop forest using Havlak&apos;s algorithm, which
</code></pre><p>第一列是flat,第二列是cum,第三列是行数</p>
<p>可以看到最占时间的是247行,他本是是个递归,先不分析<br>接下来是246行,它是从map中取值,怎么会花费这么多时间呢,对了,前面就是在分析runtime.mapaccess1_fast64的调用情况,那应该就是他了. 在242,246,250行都使用了取值操作</p>
<p>这里引用官博中的一句话</p>
<blockquote>
<p> For that particular lookup, a map is not the most efficient choice. Just as they would be in a compiler, the basic block structures have unique sequence numbers assigned to them.Instead of using a map[*BasicBlock]int we can use a []int, a slice indexed by the block number. There’s no reason to use a map when an array or slice will do.</p>
</blockquote>
<blockquote>
<p>意思是对于某些特殊查询,map不是最有效的选择.就像它们在编译器中一样，基本块结构具有分配给它们的唯一序列号.使用切片[]int是一个更好的选择. 在array或者slice可以解决的情况下,没理由去使用map.(但是我觉得map方便啊…捂脸)</p>
</blockquote>
<p>我的理解是因为数组是在内存中连续存储的,所以查询能在O(1)时间内完成,而map在数据量较大是,在对hash值进行查询的时候,性能可能会收到影响.</p>
<h3 id="havlak2"><a href="#havlak2" class="headerlink" title="havlak2"></a>havlak2</h3><p>在对havlak1修改以后,形式好了很多.具体修改哪些,可以看<a href="https://github.com/rsc/benchgraffiti/commit/58ac27bcac3ffb553c29d0b3fb64745c91c95948" target="_blank" rel="noopener">这里</a></p>
<p>看一下havlak2的pprof</p>
<pre><code>➜  havlak go build havlak2.go
➜  havlak ./havlak2 -cpuprofile=havlak2.prof
# of loops: 76000 (including 1 artificial root node)
➜  havlak go tool pprof havlak2 havlak2.prof
File: havlak2
Type: cpu
Time: Mar 30, 2018 at 7:10pm (CST)
Duration: 13.11s, Total samples = 17.55s (133.83%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top5  
Showing nodes accounting for 8410ms, 47.92% of 17550ms total
Dropped 93 nodes (cum &lt;= 87.75ms)
Showing top 5 nodes out of 72
    flat  flat%   sum%        cum   cum%
    2730ms 15.56% 15.56%     5630ms 32.08%  runtime.scanobject /usr/local/go/src/runtime/mgcmark.go
    1990ms 11.34% 26.89%    10290ms 58.63%  main.FindLoops /home/skt/mygo/src/benchgraffiti/havlak/havlak2.go
    1600ms  9.12% 36.01%     1600ms  9.12%  runtime.heapBitsForObject /usr/local/go/src/runtime/mbitmap.go
    1300ms  7.41% 43.42%     4370ms 24.90%  runtime.mallocgc /usr/local/go/src/runtime/malloc.go
    790ms  4.50% 47.92%      800ms  4.56%  runtime.greyobject /usr/local/go/src/runtime/mgcmark.go
</code></pre><p>哇哦! 之前的<strong>DFS</strong>和<strong>runtime.mapaccess1_fast64</strong>都不见了.现在被调用次数最多的是runtime.scanobject(15.56%)和main.FindLoops(11.34%).</p>
<p><strong>我试了一下list main.FindLoops,显示了FindLoops之外的代码.应该是因为没有函数内联导致的.</strong></p>
<p>先来分析runtime.scanobject,这个是和gc相关的扫描函数,有调度器调用,那么是什么导致调度器调用这个函数呢,应该是某些地方对象创建频繁,导致频繁gc.</p>
<p>涉及到内存分配,单从cpu-pprof是不好找原因的,那么从mem-pprof入手. </p>
<h3 id="havlak3"><a href="#havlak3" class="headerlink" title="havlak3"></a>havlak3</h3><p>havlak3提供了memprofile参数,可以生成mem-pprof. (<a href="https://github.com/rsc/benchgraffiti/commit/b78dac106bea1eb3be6bb3ca5dba57c130268232" target="_blank" rel="noopener">这里</a>可以看havlak3.go和havlak2.go的区别)</p>
<pre><code>➜  havlak go build -gcflags &apos;-N -l&apos; havlak3.go //禁止内联优化
➜  havlak ./havlak3 -memprofile=havlak3.mprof
➜  havlak go tool pprof havlak3 havlak3.mprof
File: havlak3
Type: inuse_space
Time: Mar 30, 2018 at 7:48pm (CST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top5
Showing nodes accounting for 60.89MB, 100% of 60.89MB total
Showing top 5 nodes out of 13
    flat  flat%   sum%        cum   cum%
33.10MB 54.36% 54.36%    33.10MB 54.36%  main.FindLoops /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
    20MB 32.85% 87.21%       20MB 32.85%  main.NewBasicBlock /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
    3MB  4.93% 92.13%        3MB  4.93%  main.(*BasicBlock).AddInEdge /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
    2.50MB  4.11% 96.24%     2.50MB  4.11%  main.(*BasicBlock).AddOutEdge /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
    2.29MB  3.76%   100%    22.29MB 36.61%  main.(*CFG).CreateNode /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
(pprof) 
</code></pre><p>main.FindLoops名列前茅,终究还是回到他这里了.</p>
<pre><code>(pprof) list FindLoops
Total: 60.89MB
ROUTINE ======================== main.FindLoops in /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
33.10MB    33.10MB (flat, cum) 54.36% of Total
        .          .    263:        return
        .          .    264:    }
        .          .    265:
        .          .    266:    size := cfgraph.NumNodes()
        .          .    267:
    1.97MB     1.97MB   268:    nonBackPreds := make([]map[int]bool, size)
    5.77MB     5.77MB   269:    backPreds := make([][]int, size)
        .          .    270:
    1.97MB     1.97MB   271:    number := make([]int, size)
    1.97MB     1.97MB   272:    header := make([]int, size, size)
    1.97MB     1.97MB   273:    types := make([]int, size, size)
    1.97MB     1.97MB   274:    last := make([]int, size, size)
    1.97MB     1.97MB   275:    nodes := make([]*UnionFindNode, size, size)
        .          .    276:
        .          .    277:    for i := 0; i &lt; size; i++ {
    5MB        5MB      278:        nodes[i] = new(UnionFindNode)
        .          .    279:    }
        .          .    280:
        .          .    281:    // Step a:
        .          .    282:    //   - initialize all nodes as unvisited.
        .          .    283:    //   - depth-first traversal and numbering.
        .          .    284:    //   - unreached BB&apos;s are marked as dead.
        .          .    285:    //
        .          .    286:    for i, bb := range cfgraph.Blocks {
        .          .    287:        number[bb.Name] = unvisited
    10.50MB    10.50MB  288:        nonBackPreds[i] = make(map[int]bool)
        .          .    289:    }
        .          .    290:
        .          .    291:    DFS(cfgraph.Start, nodes, number, last, 0)
        .          .    292:
        .          .    293:    // Step b:
</code></pre><p>第288行,又是因为可以用简单的数据结构切片或者数组时,却创建了map,且花费了10.5M的内存</p>
<p>另一方面,使用go tool pprof –inuse_objects havlak3 havlak3.mprof 可以显示创建内存的次数,而不是.这一点更符合寻找gc压力的目的.</p>
<pre><code>➜  havlak go tool pprof --inuse_objects havlak3 havlak3.mprof
File: havlak3
Type: inuse_objects
Time: Mar 30, 2018 at 7:48pm (CST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) list FindLoops
Total: 1245227
ROUTINE ======================== main.FindLoops in /home/skt/mygo/src/benchgraffiti/havlak/havlak3.go
393238     393238 (flat, cum) 31.58% of Total
     .          .    263:        return
     .          .    264:    }
     .          .    265:
     .          .    266:    size := cfgraph.NumNodes()
     .          .    267:
     1          1    268:    nonBackPreds := make([]map[int]bool, size)
     1          1    269:    backPreds := make([][]int, size)
     .          .    270:
     1          1    271:    number := make([]int, size)
     1          1    272:    header := make([]int, size, size)
     1          1    273:    types := make([]int, size, size)
     1          1    274:    last := make([]int, size, size)
     1          1    275:    nodes := make([]*UnionFindNode, size, size)
     .          .    276:
     .          .    277:    for i := 0; i &lt; size; i++ {
163845     163845    278:        nodes[i] = new(UnionFindNode)
     .          .    279:    }
     .          .    280:
     .          .    281:    // Step a:
     .          .    282:    //   - initialize all nodes as unvisited.
     .          .    283:    //   - depth-first traversal and numbering.
     .          .    284:    //   - unreached BB&apos;s are marked as dead.
     .          .    285:    //
     .          .    286:    for i, bb := range cfgraph.Blocks {
     .          .    287:        number[bb.Name] = unvisited
229386     229386    288:        nonBackPreds[i] = make(map[int]bool)
     .          .    289:    }
     .          .    290:
     .          .    291:    DFS(cfgraph.Start, nodes, number, last, 0)
     .          .    292:
     .          .    293:    // Step b:
</code></pre><p>官博中写到</p>
<blockquote>
<p>That’s reasonable when a map is being used to hold key-value pairs, but not when a map is being used as a stand-in for a simple set, as it is here.</p>
</blockquote>
<blockquote>
<p>在处理key-value数据时,用map是合适的,但是在处理简单的set集合类型时,map不一定是好的选择</p>
</blockquote>
<h3 id="havlak4"><a href="#havlak4" class="headerlink" title="havlak4"></a>havlak4</h3><p>在havlak4.go中使用了数组来替代map,<a href="https://github.com/rsc/benchgraffiti/commit/245d899f7b1a33b0c8148a4cd147cb3de5228c8a" target="_blank" rel="noopener">这里</a>可以看到和havlak3.go的区别</p>
<p>最开始我是想一个map和array差别真的就这么大么,有点不相信哎.</p>
<p>恰好在这个项目中执行xtime,可以输出二进制文件的耗时和内存占用情况</p>
<pre><code>➜  havlak ./xtime ./havlak3
# of loops: 76000 (including 1 artificial root node)
19.33u 0.16s 13.70r 303024kB ./havlak3
➜  havlak ./xtime ./havlak4
# of loops: 76000 (including 1 artificial root node)
11.44u 0.06s 8.41r 166100kB ./havlak4
</code></pre><p>xtime 输出三个时间和一个内存占用</p>
<ul>
<li>usr_time 用户态时间</li>
<li>sys_time 系统态时间</li>
<li>real_time 实际花费时间</li>
<li>memory 运行内存 </li>
</ul>
<p>可以看到havlak4提高了将近40%的性能…捂脸</p>
<p>现在,比较<strong>havlak4</strong>和<strong>havlak2</strong>. 跳过<strong>havlak3</strong>版本,因为该版本只是加了一个memprof参数,</p>
<pre><code>➜  havlak go build -gcflags &apos;-N -l&apos; havlak4.go
➜  havlak ./havlak4 -cpuprofile=havlak4.prof
# of loops: 76000 (including 1 artificial root node)
➜  havlak go tool pprof havlak4 havlak4.prof
File: havlak4
Type: cpu
Time: Mar 30, 2018 at 8:40pm (CST)
Duration: 8.16s, Total samples = 10.62s (130.14%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top5
Showing nodes accounting for 5990ms, 56.40% of 10620ms total
Dropped 71 nodes (cum &lt;= 53.10ms)
Showing top 5 nodes out of 69
  flat  flat%   sum%        cum   cum%
1920ms 18.08% 18.08%     3740ms 35.22%  runtime.scanobject /usr/local/go/src/runtime/mgcmark.go
1720ms 16.20% 34.27%     5710ms 53.77%  main.FindLoops /home/skt/mygo/src/benchgraffiti/havlak/havlak4.go
1010ms  9.51% 43.79%     1010ms  9.51%  runtime.heapBitsForObject /usr/local/go/src/runtime/mbitmap.go
 690ms  6.50% 50.28%      810ms  7.63%  main.DFS /home/skt/mygo/src/benchgraffiti/havlak/havlak4.go
 650ms  6.12% 56.40%     2550ms 24.01%  runtime.mallocgc /usr/local/go/src/runtime/malloc.go
</code></pre><p>看cum列:</p>
<pre><code>                                havlak2    havlak4

- runtime.scanobject:           5630ms  -&gt; 3740ms
- main.FindLoops                10290ms -&gt; 5710ms
- runtime.heapBitsForObject     1600ms  -&gt; 1010ms
- runtime.mallocgc              4370ms  -&gt; 2550ms
</code></pre><p>数值上,优化了不少.但是现在问题还是在main.FindLoops, runtime.scanobject, runtime.mallocgc上.FindLoops先不管,我想知道是什么导致了<strong>scanobject</strong>和<strong>mallocgc</strong>的调用.</p>
<p>先看scanobject</p>
<pre><code>(pprof) web runtime.scanobject
</code></pre><img src="/2018/03/30/golang-pprof实践/havlak4_scanobject.svg" title="右键新标签页打开,可看大图">
<p>可以看到主要是FindLoops里面用了makeslice,从而导致mallocgc,然后导致scanobject.</p>
<p>再看mallocgc</p>
<pre><code>(pprof) web runtime.mallocgc
</code></pre><img src="/2018/03/30/golang-pprof实践/havlak4_mallocgc.svg" title="右键新标签页打开,可看大图">
<p>mallocgc的调用关系有点复杂,但是通过web页面的方块颜色还是可以明显看出<strong>FindLoops</strong>调用了<strong>newobjec</strong>和<strong>growslice</strong>,从而导致<strong>mallocgc</strong>的调用.</p>
<p>那么问题就集中到FindLoops身上了</p>
<pre><code>(pprof) list FindLoops
Total: 10.62s
ROUTINE ======================== main.FindLoops in /home/skt/mygo/src/benchgraffiti/havlak/havlak4.go
 1.72s      5.71s (flat, cum) 53.77% of Total
     .          .    272:        return
     .          .    273:    }
     .          .    274:
     .          .    275:    size := cfgraph.NumNodes()
     .          .    276:
     .       30ms    277:    nonBackPreds := make([][]int, size)
     .      280ms    278:    backPreds := make([][]int, size)
     .          .    279:
     .      170ms    280:    number := make([]int, size)
     .       20ms    281:    header := make([]int, size, size)
     .       40ms    282:    types := make([]int, size, size)
     .       10ms    283:    last := make([]int, size, size)
     .       20ms    284:    nodes := make([]*UnionFindNode, size, size)
     .          .    285:
     .          .    286:    for i := 0; i &lt; size; i++ {
  30ms      460ms    287:        nodes[i] = new(UnionFindNode)
     .          .    288:    }
</code></pre><p>下面是官博中的引用</p>
<blockquote>
<p>Every time FindLoops is called, it allocates some sizable bookkeeping structures. Since the benchmark calls FindLoops 50 times, these add up to a significant amount of garbage, so a significant amount of work for the garbage collector.</p>
</blockquote>
<blockquote>
<p>Having a garbage-collected language doesn’t mean you can ignore memory allocation issues. In this case, a simple solution is to introduce a cache so that each call to FindLoops reuses the previous call’s storage when possible. (In fact, in Hundt’s paper, he explains that the Java program needed just this change to get anything like reasonable performance, but he did not make the same change in the other garbage-collected implementations.)</p>
</blockquote>
<p>每次调用<strong>FindLoops</strong>都会创建大量的对象(278,280),连续调用<strong>FindLoops</strong>后,就有可能<br>触发GC.</p>
<p>虽然golang是一门自带垃圾回收的语言,但是这不代表我们可以随意的创建对象.如果可以的话,应该考虑对象重用,或者创建一个cache缓存.</p>
<h3 id="havlak5"><a href="#havlak5" class="headerlink" title="havlak5"></a>havlak5</h3><p>可以创建一个本地的cache对象</p>
<pre><code>var cache struct {
    size int
    nonBackPreds [][]int
    backPreds [][]int
    number []int
    header []int
    types []int
    last []int
    nodes []*UnionFindNode
}
</code></pre><p>然后每次FindLoops去查询缓存,而不是直接创建对象</p>
<pre><code>if cache.size &lt; size {
    cache.size = size
    cache.nonBackPreds = make([][]int, size)
    cache.backPreds = make([][]int, size)
    cache.number = make([]int, size)
    cache.header = make([]int, size)
    cache.types = make([]int, size)
    cache.last = make([]int, size)
    cache.nodes = make([]*UnionFindNode, size)
    for i := range cache.nodes {
        cache.nodes[i] = new(UnionFindNode)
    }
}

nonBackPreds := cache.nonBackPreds[:size]
for i := range nonBackPreds {
    nonBackPreds[i] = nonBackPreds[i][:0]
}
backPreds := cache.backPreds[:size]
for i := range nonBackPreds {
    backPreds[i] = backPreds[i][:0]
}
number := cache.number[:size]
header := cache.header[:size]
types := cache.types[:size]
last := cache.last[:size]
nodes := cache.nodes[:size]
</code></pre><p>这里有个疑问,重用cache的时候,难道不需要对cache值初始化吗,否则上次调用的产生的结果会对当前值产生影响吧.</p>
<p><a href="https://github.com/rsc/benchgraffiti/commit/2d41d6d16286b8146a3f697dd4074deac60d12a4" target="_blank" rel="noopener">这里</a>可以看到havlak5和havlak4的区别</p>
<p>现在用xtime比较一下havlak5和havlak4的性能</p>
<pre><code>➜  havlak ./xtime ./havlak4                   
# of loops: 76000 (including 1 artificial root node)
11.09u 0.08s 8.11r 165820kB ./havlak4
➜  havlak ./xtime ./havlak5
# of loops: 76000 (including 1 artificial root node)
7.27u 0.06s 5.48r 171320kB ./havlak5
</code></pre><p>运行时间从8.11s到5.48s,提升了%25的性能,但是不知道为什么,内存占用反而更多了.</p>
<h3 id="havlak6"><a href="#havlak6" class="headerlink" title="havlak6"></a>havlak6</h3><p>官博中提到,havlak6主要是对迭代做了一些优化,因为具体代码我没仔细研究,所以这里就不介绍了</p>
<p>以及使用了更地道的Go风格,数据结构+方法的形式,这个对运行时影响不大</p>
<p>比较一下和上个版本的性能</p>
<pre><code>➜  havlak ./xtime ./havlak5
# of loops: 76000 (including 1 artificial root node)
7.27u 0.06s 5.48r 171320kB ./havlak5
➜  havlak go build -gcflags=&quot;-N -l&quot; havlak6.go
➜  havlak ./xtime ./havlak6                   
# of loops: 76000 (including 1 artificial root node)
2.90u 0.03s 2.71r 87524kB ./havlak6
</code></pre><p>运行时间从5.48s优化到2.71s</p>
<p>接下来,文章中用c++代码重写havlak6的代码,对比了一下不同语言之间的性能,go运行时间稍微大于c++</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a><strong>优化思路</strong></h3><p>topN中,如果排在前面的是runtime函数,可以用pprof web runtime.xxx被调用的原因,一直向上层寻找自己的代码</p>
<p>如果排在前面的是自己的代码,说明自己的这块代码被调用次数较多,如果函数对应的cum值也比较高,很有可能自己的这块代码有问题,可以用pprof list xxxx,查看具体是哪一行导致的问题</p>
<h3 id="优化的时候-是看主要flat列还是cum列"><a href="#优化的时候-是看主要flat列还是cum列" class="headerlink" title="优化的时候,是看主要flat列还是cum列?"></a><strong>优化的时候,是看主要flat列还是cum列?</strong></h3><p>可以先选择优化flat列,因为flat可以看成是函数被调用次数,所以对flat值比较高函数进行优化时,优化收益可以看成是被调用次数*本次优化值</p>
<h3 id="cum值较高-可能的原因是什么"><a href="#cum值较高-可能的原因是什么" class="headerlink" title="cum值较高,可能的原因是什么?"></a><strong>cum值较高,可能的原因是什么?</strong></h3><p>cum值表示整个函数(包括内部调用其它函数)的运行时间,如果cum值较高,有两种原因:</p>
<ul>
<li>函数内部的其他函数比较耗时</li>
<li>函数中golang的内置函数比较费时,例如make,append,new,map寻值</li>
</ul>
<h3 id="什么时候用cpupprof-什么时候用mempprof"><a href="#什么时候用cpupprof-什么时候用mempprof" class="headerlink" title="什么时候用cpupprof,什么时候用mempprof"></a><strong>什么时候用cpupprof,什么时候用mempprof</strong></h3><p>可以先分析cpupprof,如果其中发现gc相关的代码占用时间较多的话,可以再去分析mempprof</p>
<h3 id="如果在topN中显示标准包的一些函数占用时间较多-怎么去优化我的程序呢"><a href="#如果在topN中显示标准包的一些函数占用时间较多-怎么去优化我的程序呢" class="headerlink" title="如果在topN中显示标准包的一些函数占用时间较多,怎么去优化我的程序呢."></a><strong>如果在topN中显示标准包的一些函数占用时间较多,怎么去优化我的程序呢.</strong></h3><p>先用pprof web runtime.xxx命令,找到是哪些程序调用了这个标准包函数,然后依次向上层寻找跟我的程序有关的函数名</p>
<h3 id="已经定位到了某个函数有问提-怎么确定是哪一行"><a href="#已经定位到了某个函数有问提-怎么确定是哪一行" class="headerlink" title="已经定位到了某个函数有问提,怎么确定是哪一行?"></a><strong>已经定位到了某个函数有问提,怎么确定是哪一行?</strong></h3><p>可以用pprof list xxx, 注意编译的时候禁止函数内联,否则list会展示其他函数名</p>
<h3 id="平时写代码-需要注意哪些坑呢"><a href="#平时写代码-需要注意哪些坑呢" class="headerlink" title="平时写代码,需要注意哪些坑呢"></a><strong>平时写代码,需要注意哪些坑呢</strong></h3><ul>
<li>能用切片,数组解决的,就不要用map,一方面是可能查询会慢,另一方面map分配内存也更多</li>
<li>如果可以的话,尽量重用对象</li>
<li>map,slice在创建的时候,尽量声明大小,较低扩容函数的调用</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>阅读这篇博客+实践+记录,大概花费了我10个小时的时间.</p>
<p>虽然我的英语水平不是很好,但是这篇英文博客看下来竟然感觉非常的爽!推荐大家花几个小时照着博客也去实践一下</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://colobu.com/2016/07/04/dive-into-go-11/" target="_blank" rel="noopener">鸟窝博客-深入Go语言</a></p>
<p><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">golang官博</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/26/nsqd-mysql保存消息历史/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yh Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/git.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/26/nsqd-mysql保存消息历史/" itemprop="url">nsqd+mysql保存消息历史</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-26T15:33:48+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/02/26/nsqd-mysql保存消息历史/nsqd.png" title="nsqd消息分发流程">
<h2 id="改造原因"><a href="#改造原因" class="headerlink" title="改造原因"></a>改造原因</h2><p>nsqd自带消息持久化特性（nsqd的消费者因为某些原因断掉，在重新连接后仍然可以继续消费）。团队使用nsqd作为消息队列时，遇到一些问题：虽然nsqd自带消息持久化特性（nsqd的消费者因为某些原因断掉，在重新连接后仍然可以继续消费），也可以通过nsqadmin管理页面查看nsq各个节点的运行情况，但无法了解具体某个消息的生命周期。如果能将nsqd的推送记录和消费记录保存在mysql中，则可以解决痛点。</p>
<h2 id="尝试解决方案"><a href="#尝试解决方案" class="headerlink" title="尝试解决方案"></a>尝试解决方案</h2><h3 id="方案1：对go-nsq进行简单封装"><a href="#方案1：对go-nsq进行简单封装" class="headerlink" title="方案1：对go-nsq进行简单封装"></a>方案1：对go-nsq进行简单封装</h3><ul>
<li><p>在gopath下,新建znsq目录,作为项目包</p>
<img src="/2018/02/26/nsqd-mysql保存消息历史/znsq_dir.png" title="znsq项目目录">
</li>
<li><p>对生产者的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package znsq</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;znsq/models&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/astaxie/beego/orm&quot;</span><br><span class="line">	&quot;github.com/nsqio/go-nsq&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Producer struct &#123;</span><br><span class="line">	P *nsq.Producer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化生产者</span><br><span class="line">func NewProducer(addr string, mysql string) (wr *Producer) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	cfg := nsq.NewConfig()</span><br><span class="line">	p, err := nsq.NewProducer(addr, cfg)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	p.SetLogger(log.New(os.Stdout, &quot;nsq:&quot;, 0), nsq.LogLevelInfo)</span><br><span class="line">	wr = &amp;Producer&#123;P: p&#125;</span><br><span class="line">	orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, mysql, 10, 10) // 注册数据库</span><br><span class="line">	return wr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对go-nsq的Publish方法封装</span><br><span class="line">func (p *Producer) Publish(topic string, body []byte) error &#123;</span><br><span class="line">	go p.PublishLog(topic, body) // 添加日志</span><br><span class="line">	return p.P.Publish(topic, body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Producer) PublishLog(topic string, body []byte) (int64, error) &#123;</span><br><span class="line">	log := &amp;models.NsqPublishLog&#123;&#125;</span><br><span class="line">	// log.MessageId = &quot;&quot; // 因为messageId由nsqd生成,所以这里还无法获取messageId</span><br><span class="line">	log.Message = string(body)</span><br><span class="line">	log.NsqdUrl = p.P.String()</span><br><span class="line">	log.Topic = topic</span><br><span class="line">	return models.AddNsqPublishLog(log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对消费者的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package znsq</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;znsq/models&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/astaxie/beego/orm&quot;</span><br><span class="line">	_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">	nsq &quot;github.com/nsqio/go-nsq&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func NewNsqConsumer(topic, channel, address, mysql string, handle nsq.Handler) *nsq.Consumer &#123;</span><br><span class="line">	cfg := nsq.NewConfig()</span><br><span class="line">	cfg.LookupdPollInterval = time.Second</span><br><span class="line">	c, err := nsq.NewConsumer(topic, channel, cfg) // 新建一个消费者</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.SetLogger(nil, 0)</span><br><span class="line"></span><br><span class="line">	rg := &amp;handlerRegist&#123;</span><br><span class="line">		h:       handle,</span><br><span class="line">		topic:   topic,</span><br><span class="line">		channel: channel,</span><br><span class="line">		nsqd:    address,</span><br><span class="line">	&#125;</span><br><span class="line">	c.AddHandler(rg)                                        // 添加消费者接口</span><br><span class="line">	orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, mysql, 10, 10) // 注册数据库</span><br><span class="line">	if err := c.ConnectToNSQD(address); err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type handlerRegist struct &#123;</span><br><span class="line">	h       nsq.Handler</span><br><span class="line">	topic   string</span><br><span class="line">	channel string</span><br><span class="line">	nsqd    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对调用方的handel封装</span><br><span class="line">func (rg *handlerRegist) HandleMessage(message *nsq.Message) error &#123;</span><br><span class="line">	go rg.ConsumeLog(message) // 不知道会不会造成gc压力</span><br><span class="line">	return rg.h.HandleMessage(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加消费日志到mysql</span><br><span class="line">func (rg *handlerRegist) ConsumeLog(message *nsq.Message) (int64, error) &#123;</span><br><span class="line">	log := &amp;models.NsqConsumeLog&#123;&#125;</span><br><span class="line">	log.NsqdUrl = rg.nsqd</span><br><span class="line">	log.Topic = rg.topic</span><br><span class="line">	log.Channel = rg.channel</span><br><span class="line">	log.Message = string(message.Body)</span><br><span class="line">	log.MessageId = fmt.Sprintf(&quot;%s&quot;, message.ID)</span><br><span class="line">	return models.AddNsqConsumeLog(log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该方法的优点：在不对官方项目做任何修改的前提下，就可以记录消息生命周期。<br>该方法的缺点：因为nsqd的publish消息成功的时候，不会返回message_id,而且go-nsq项目的publish方法的返回值只有一个error类型，所以在记录publish日志时，无法获得message_id，这样就无法查看某一个消息的publish和consume的日志。</p>
<h3 id="方案2：修改go-nsq代码以及nsqd代码"><a href="#方案2：修改go-nsq代码以及nsqd代码" class="headerlink" title="方案2：修改go-nsq代码以及nsqd代码"></a>方案2：修改go-nsq代码以及nsqd代码</h3><ul>
<li><p>根据文章中的图片找到publish和consum相关部分的代码</p>
</li>
<li><p>修改go-nsq的publish方法，额外添加一个返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 没有亲自实现,代码略</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改nsqd项目的protocal.Pub方法，额外返回一个message_id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// github.com/nsqio/nsq/protocal_v2.go</span><br><span class="line">func (p *protocolV2) PUB(client *clientV2, params [][]byte) ([]byte, error) &#123;</span><br><span class="line">	// ...</span><br><span class="line">	return []byte(fmt.Sprintf(&quot;%s %s&quot;, okBytes, msg.ID)), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该方法的优点：解决了方案1的问题。<br>该方法的缺点：需要修改2个官方项目，改动过大。</p>
<h3 id="方案3：只修改nsqd代码，为nsqd运行选项添加-mysql参数"><a href="#方案3：只修改nsqd代码，为nsqd运行选项添加-mysql参数" class="headerlink" title="方案3：只修改nsqd代码，为nsqd运行选项添加 -mysql参数"></a>方案3：只修改nsqd代码，为nsqd运行选项添加 -mysql参数</h3><ul>
<li><p>添加publish_log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// github.com/LvBay/nsq/nsqd/topic.go</span><br><span class="line">func (t *Topic) put(m *Message) error &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case t.memoryMsgChan &lt;- m:</span><br><span class="line">	default:</span><br><span class="line">		b := bufferPoolGet()</span><br><span class="line">		err := writeMessageToBackend(b, m, t.backend)</span><br><span class="line">		bufferPoolPut(b)</span><br><span class="line">		t.ctx.nsqd.SetHealth(err)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line">				&quot;TOPIC(%s) ERROR: failed to write message to backend - %s&quot;,</span><br><span class="line">				t.name, err)</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if t.ctx.nsqd.getOpts().MysqlUrl != &quot;&quot; &#123;</span><br><span class="line">		go t.PublishLog(m)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// github.com/LvBay/nsq/nsqd/topic.go</span><br><span class="line">func (t *Topic) PublishLog(m *Message) error &#123;</span><br><span class="line">	log := &amp;NsqPublishLog&#123;&#125;</span><br><span class="line">	log.Topic = t.name</span><br><span class="line">	log.Message = string(m.Body)</span><br><span class="line">	log.NsqdUrl = t.ctx.nsqd.getOpts().TCPAddress</span><br><span class="line">	log.MessageId = fmt.Sprintf(&quot;%s&quot;, m.ID)</span><br><span class="line">	_, err := AddNsqPublishLog(log)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		beego.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加consume_log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// github.com/LvBay/nsq/nsqd/protocol_v2.go</span><br><span class="line">func (p *protocolV2) messagePump(client *clientV2, startedChan chan bool) &#123;</span><br><span class="line">	// ...</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		// ...</span><br><span class="line"></span><br><span class="line">		select &#123;</span><br><span class="line">		// ...</span><br><span class="line">		case msg := &lt;-memoryMsgChan:</span><br><span class="line">			if sampleRate &gt; 0 &amp;&amp; rand.Int31n(100) &gt; sampleRate &#123;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			msg.Attempts++</span><br><span class="line"></span><br><span class="line">			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</span><br><span class="line">			client.SendingMessage()</span><br><span class="line">			err = p.SendMessage(client, msg, &amp;buf)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				goto exit</span><br><span class="line">			&#125;</span><br><span class="line">			// 添加consume日志</span><br><span class="line">			if client.ctx.nsqd.getOpts().MysqlUrl != &quot;&quot; &#123;</span><br><span class="line">				go client.Channel.ConsumeLog(msg)</span><br><span class="line">			&#125;</span><br><span class="line">			flushed = false</span><br><span class="line">		case &lt;-client.ExitChan:</span><br><span class="line">			goto exit</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	p.ctx.nsqd.logf(LOG_INFO, &quot;PROTOCOL(V2): [%s] exiting messagePump&quot;, client)</span><br><span class="line">	heartbeatTicker.Stop()</span><br><span class="line">	outputBufferTicker.Stop()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		p.ctx.nsqd.logf(LOG_ERROR, &quot;PROTOCOL(V2): [%s] messagePump error - %s&quot;, client, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// github.com/LvBay/nsq/nsqd/channel.go</span><br><span class="line">func (c *Channel) ConsumeLog(m *Message) error &#123;</span><br><span class="line">	log := &amp;NsqConsumeLog&#123;&#125;</span><br><span class="line">	log.Topic = c.topicName</span><br><span class="line">	log.Channel = c.name</span><br><span class="line">	log.Message = string(m.Body)</span><br><span class="line">	log.NsqdUrl = c.ctx.nsqd.getOpts().TCPAddress</span><br><span class="line">	log.MessageId = fmt.Sprintf(&quot;%s&quot;, m.ID)</span><br><span class="line">	_, err := AddNsqConsumeLog(log)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		beego.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 -mysql参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// github.com/LvBay/nsq/app/nsqd/nsqd.go</span><br><span class="line">func nsqdFlagSet(opts *nsqd.Options) *flag.FlagSet &#123;</span><br><span class="line">	// ...</span><br><span class="line">	// mysql</span><br><span class="line">	flagSet.String(&quot;mysql&quot;, opts.MysqlUrl, &quot;save messages in mysql&quot;)</span><br><span class="line">	return flagSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该方法的优点：解决了方案1中message_id的问题，同时也只修改了nsqd组件。<br>该方法的缺点：因为需要与mysql交互，在nsqd项目中加入了beego的orm模块代码，对nsqd项目入侵较严重。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们团队最终采用了第三种方案,接下来准备配合前端同学修改nsqdadmin组件,将消息历史展示在管理页面</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/git.png"
                alt="Yh Zhang" />
            
              <p class="site-author-name" itemprop="name">Yh Zhang</p>
              <p class="site-description motion-element" itemprop="description">See you again</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yh Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
